<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Arming</title>
    <link href="http://mrmign.github.io/feed/" rel="self" />
    <link href="http://mrmign.github.io" />
    <lastBuildDate>2016-01-05T00:02:42+08:00</lastBuildDate>
    <webMaster>cloudniw1@126.com</webMaster>
    
    <item>
      <title>2016计划</title>
      <link href="http://mrmign.github.io/2016/01/01/2016-ji-hua/"/>
      <pubDate>2016-01-01T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2016/01/01/2016-ji-hua</guid>
      <content:encoded><![CDATA[<p>2015已经过去，心里想要干的事情没能如数完成，藏在心里就会老是给自己找借口开脱，这里要把2016要做的事情写下来，也算有个凭据，不能再容忍自己给自己找借口了。到了2016年末写总结时，再来看这篇Todo计划，会很自豪的。</p>

<h2 id="section">读书</h2>

<h3 id="section-1">技术书</h3>

]]></content:encoded>
    </item>
    
    <item>
      <title>Google Protobuf原理学习</title>
      <link href="http://mrmign.github.io/2015/12/31/google-protobuf-yuan-li-xue-xi/"/>
      <pubDate>2015-12-31T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/31/google-protobuf-yuan-li-xue-xi</guid>
      <content:encoded><![CDATA[<h1 id="pb">Pb组包解包实现</h1>

<p>Protobuf是Google开源的一套跨平台、跨语言的序列化协议。基于Protocbuf的数据组包方式有效减了网络数据传输的大小，减少流量消耗。</p>

<p>pb协议都是通过*.proto的文件进行描述的，该描述文件是非常通用，不限制针对哪种语言，通过Google提供的compiler可以选择编译的目标编程语言，如java,C++,Python等。这里以C++为例。通过<code>protoc *.proto --cpp_out=dir</code>命令就可以根据proto描述文件生成对应的C++文件<code>*.pb.h</code>和<code>*.pb.cc</code>，然后引用相应的头文件就可以进行组包、解包了。</p>

<p>上面的做法是最基本最常用的，而且我们在使用pb协议的时候也都是这么做的。因为PbCodec不再需要生成C++的头文件了。通过描述文件生成的pb头文件给我们提供的主要方法就是一堆<code>getter</code>、<code>setter</code>、<code>serialize</code>、<code>parse</code>方法，这些方法确实方便了我们组包、解包。</p>

<p>Pb使用<code>((T)([L]V))</code>类似的格式，即Tag-Length-Value。每一个字段值都使用TLV的格式，最后将所有字段的TLV序列拼接为一个二进制字节流进行传输，收到字节流按TLV一个一个字段的解析出来。这里的Tag也可以叫做<code>key</code>，pb使用的格式抽象一下也可以看成是一个个的Key-Value对。</p>

<p>这里的Key也叫Tag是由什么组成的？我们知道在proto描述文件里message下的每个字段值都有一个field数字，表示它在message里是第几个值，我们称它为<code>field_num</code>；声明一个字段的时候还要指定该字段用来放什么类型的值，是可变长度还是固定长度等，这里的字段类型称为<code>wire_type</code>。好了，有了<code>field_num</code>和<code>wire_type</code>我们就可以得到我们的key了，<code>key = field_num &lt;&lt; 3 | wire_type</code>。</p>

<p>Protobuf里对wireType声明下面几种类型:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><a name="True-1"></a>  <span class="k">enum</span> <span class="n">WireType</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="n">WIRETYPE_VARINT</span>           <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<a name="True-3"></a>    <span class="n">WIRETYPE_FIXED64</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<a name="True-4"></a>    <span class="n">WIRETYPE_LENGTH_DELIMITED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<a name="True-5"></a>    <span class="n">WIRETYPE_START_GROUP</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<a name="True-6"></a>    <span class="n">WIRETYPE_END_GROUP</span>        <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<a name="True-7"></a>    <span class="n">WIRETYPE_FIXED32</span>          <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<a name="True-8"></a>  <span class="p">};</span></code></pre></div>
<p><img src="/images/20151231/pb-wiretype.png" alt="wireType说明" /></p>

<p><code>Varint</code>是一种比较特殊的编码方式，后面有详细介绍。<code>FixedXX</code>就是固定长度的。<code>Length_Delimited</code>是针对那些变长数据的如bytes,String,subMessage等。</p>

<p>Value的组成就是由数据长度和数据组成，但是长度可能没有，像对于数字类型的不需要长度，只有那些长度不确定的类型(bytes,string等)需要数据的真实长度才能正确解析。Protobuf的数组格式就是这样的。下面要简单分析下Protobuf的工作原理。</p>

<p>这里我们从具体的pb协议出发，逆向学习pb的原理，下面的图是来电协议<code>oidb_65f</code>和<code>oidb_931</code>里的几个message与Protobuf的类继承关系。</p>

<p><img src="/images/20151231/pb-class-relationship.png" alt="message继承图" /></p>

<p>每一条协议都在自己的命名空间中，pb的描述文件中定义的每一个message都会生成一个对应的类，从上面的类关系图中可以看到生成的类中65f协议中类的父类是<code>MessageLite</code>，而931协议中的类的父类是<code>Message</code>,<code>Message</code>又继承自<code>MessageLite</code>，<code>Message</code>类扩充了什么功能呢？我们后面再说。这里最重要是搞明白协议描述文件里的每个message最后生成的类中都有序列化，反序列码的方法了。</p>

<p>看看下面协议中的序列化方法是如何实现的:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><a name="True-1"></a><span class="kt">void</span> <span class="n">ReqBody</span><span class="o">::</span><span class="n">SerializeWithCachedSizes</span><span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">CodedOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<a name="True-2"></a><span class="c1">//optional cmd0x65f.SetMsgValidTimeReq msg_set_req = 1;</span>
<a name="True-3"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">has_msg_set_req</span><span class="p">())</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WriteMessage</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">msg_set_req</span><span class="p">(),</span><span class="n">output</span><span class="p">);</span>
<a name="True-5"></a>	<span class="p">}</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="c1">// optional cmd0x65f.SetMsgValidTimeReq msg_set_req = 1;</span>
<a name="True-8"></a><span class="kr">inline</span> <span class="kt">bool</span> <span class="n">ReqBody</span><span class="o">::</span><span class="n">has_msg_set_req</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<a name="True-9"></a>    <span class="k">return</span> <span class="p">(</span><span class="n">_has_bits_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x00000001u</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<a name="True-10"></a><span class="p">}</span></code></pre></div>
<p>从上面代码中可以看出，当要将message进行序列化时，会向<code>CodedOutputStream</code>流中填写，大家自己看一个更复杂点的pb协议的message时，当进行序列化时，会逐一对message下的每个field进行判断，也就是类似上面中的<code>has_msg_set_req()</code>，如果有设置值就会进行写操作，每当对一个字段进行设置值时都会设置对应的标志位。<code>::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];</code>对于每一个message都会根据field的个数来生成一个这样的数组，用来标志每个字段的是否有值，同样在解包的时候也会有对应设置。假设message下有40个字段，则会有<code>::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];</code>这样的数组。若对应字段有值，就调用<code>WriteXXXX</code>方法写入流中。这里会根据字段声明时的值类型调用不同的Write方法，因为在此处的field是另一个message，因此会调用<code>WriteMessage</code>方法，如果是uint32类型，刚会调用<code>WriteUInt32</code>方法，这些Write方法都是相似的。下面看<code>WriteMessage</code>实现:</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><a name="True-1"></a><span class="kt">void</span> <span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WriteMessage</span><span class="p">(</span><span class="kt">int</span> <span class="n">field_number</span><span class="p">,</span>
<a name="True-2"></a>                                  <span class="k">const</span> <span class="n">MessageLite</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span>
<a name="True-3"></a>                                  <span class="n">io</span><span class="o">::</span><span class="n">CodedOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>  <span class="n">WriteTag</span><span class="p">(</span><span class="n">field_number</span><span class="p">,</span> <span class="n">WIRETYPE_LENGTH_DELIMITED</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
<a name="True-5"></a>  <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">GetCachedSize</span><span class="p">();</span>
<a name="True-6"></a>  <span class="n">output</span><span class="o">-&gt;</span><span class="n">WriteVarint32</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<a name="True-7"></a>  <span class="n">value</span><span class="p">.</span><span class="n">SerializeWithCachedSizes</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
<a name="True-8"></a><span class="p">}</span>
<a name="True-9"></a>
<a name="True-10"></a><span class="kr">inline</span> <span class="kt">void</span> <span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WriteTag</span><span class="p">(</span><span class="kt">int</span> <span class="n">field_number</span><span class="p">,</span> <span class="n">WireType</span> <span class="n">type</span><span class="p">,</span>
<a name="True-11"></a>                                     <span class="n">io</span><span class="o">::</span><span class="n">CodedOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
<a name="True-12"></a>  <span class="n">output</span><span class="o">-&gt;</span><span class="n">WriteTag</span><span class="p">(</span><span class="n">MakeTag</span><span class="p">(</span><span class="n">field_number</span><span class="p">,</span> <span class="n">type</span><span class="p">));</span>
<a name="True-13"></a><span class="p">}</span>
<a name="True-14"></a>
<a name="True-15"></a><span class="kr">inline</span> <span class="n">uint32</span> <span class="n">WireFormatLite</span><span class="o">::</span><span class="n">MakeTag</span><span class="p">(</span><span class="kt">int</span> <span class="n">field_number</span><span class="p">,</span> <span class="n">WireType</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<a name="True-16"></a>  <span class="k">return</span> <span class="n">GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG</span><span class="p">(</span><span class="n">field_number</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<a name="True-17"></a><span class="p">}</span>
<a name="True-18"></a>
<a name="True-19"></a><span class="cp">#define GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(FIELD_NUMBER, TYPE)                  \</span>
<a name="True-20"></a><span class="cp">  static_cast&lt;uint32&gt;(                                                   \</span>
<a name="True-21"></a><span class="cp">    ((FIELD_NUMBER) &lt;&lt; ::google::protobuf::internal::WireFormatLite::kTagTypeBits) \</span>
<a name="True-22"></a><span class="cp">      | (TYPE))</span></code></pre></div>
<p><code>WriteMessage</code>的第一个参数是field_number也就是message中字段的序号，从前面也看到在调用的时候传的第一个参数的值是<code>1</code>，也就是field的序号。方法中首先调用<code>WriteTag</code>方法，从代码中可以看出Tag就是按照之前说的方法<code>field_num &lt;&lt; 3 | wire_type</code>生成的。写完tag,因为WireType是变长的，因此要告诉数据长度，接着写数据长度<code>output-&gt;WriteVarint32(size);</code>,后面再写入数据。 这样message的序列化的核心工作就完成了，当然我们不会直接调用这里的<code>ReqBody::SerializeWithCachedSizes</code>方法来生成组包的数据buffer。我们调用的序列化方法是<code>MessageLite::SerializeAsString()</code>或是<code>MessageLite::SerializeToString(string* output)</code>，然后这两个方法再经过层层调用到达我们的message的<code>SerializeWithCachedSizes</code>方法，最终得到序列化后的结果。</p>

<p>现在pb如何进行序列化我们已经知道了，现在看pb怎么进行反序列化。先上代码了解下：</p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><a name="True-1"></a><span class="kt">bool</span> <span class="n">RspBody</span><span class="o">::</span><span class="n">MergePartialFromCodedStream</span><span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">CodedInputStream</span><span class="o">*</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
<a name="True-2"></a><span class="cp">#define DO_(EXPRESSION) if (!(EXPRESSION)) return false</span>
<a name="True-3"></a>    <span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">uint32</span> <span class="n">tag</span><span class="p">;</span>
<a name="True-4"></a>    <span class="k">while</span> <span class="p">((</span><span class="n">tag</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">ReadTag</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>        <span class="k">switch</span> <span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">GetTagFieldNumber</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span> <span class="p">{</span>
<a name="True-6"></a>                <span class="c1">// optional cmd0x65f.SetMsgValidTimeRsp msg_set_rsp = 1;</span>
<a name="True-7"></a>            <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
<a name="True-8"></a>                <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">GetTagWireType</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="o">==</span>
<a name="True-9"></a>                    <span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WIRETYPE_LENGTH_DELIMITED</span><span class="p">)</span> <span class="p">{</span>
<a name="True-10"></a>                    <span class="n">DO_</span><span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">ReadMessageNoVirtual</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">mutable_msg_set_rsp</span><span class="p">()));</span>
<a name="True-11"></a>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<a name="True-12"></a>                    <span class="k">goto</span> <span class="n">handle_uninterpreted</span><span class="p">;</span>
<a name="True-13"></a>                <span class="p">}</span>
<a name="True-14"></a>                <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">ExpectAtEnd</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<a name="True-15"></a>                <span class="k">break</span><span class="p">;</span>
<a name="True-16"></a>            <span class="p">}</span>
<a name="True-17"></a>                
<a name="True-18"></a>            <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
<a name="True-19"></a>            <span class="nl">handle_uninterpreted</span><span class="p">:</span>
<a name="True-20"></a>                <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">GetTagWireType</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="o">==</span>
<a name="True-21"></a>                    <span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WIRETYPE_END_GROUP</span><span class="p">)</span> <span class="p">{</span>
<a name="True-22"></a>                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<a name="True-23"></a>                <span class="p">}</span>
<a name="True-24"></a>                <span class="n">DO_</span><span class="p">(</span><span class="o">::</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">SkipField</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>
<a name="True-25"></a>                <span class="k">break</span><span class="p">;</span>
<a name="True-26"></a>            <span class="p">}</span>
<a name="True-27"></a>        <span class="p">}</span>
<a name="True-28"></a>    <span class="p">}</span>
<a name="True-29"></a>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<a name="True-30"></a><span class="cp">#undef DO_</span>
<a name="True-31"></a><span class="p">}</span></code></pre></div>
<p>上面的反序列化代码是针对特定message的，因此每个message都会有自己的反序列化实现。上面反序列化方法的参数是一个输入流，不用想也知道是一串二进制流，通过循环不停的读取tag，然后根据tag得到field_num，然后就是读值了。首先有没有这样的疑问，pb怎么知道读出来的WireType是对的呢，跟哪种类型进行比较呢？因为在根据描述文件生成这些方法的时候都知道每个字段的数据类型，也就知道在序列化时用的是哪个WireType了，同样也知道该调用哪个方法来读取值，并写入哪个字段。在搞明白了序列化操作后，反序列化就没有那么神秘了。</p>

<p>反序列化首先要读取Tag，但是这里我们看到的是一串二进制数据，在读取Tag时如何判断结束条件呢？有了这个疑问，我们就需要了解Protobuf的<code>Varint</code>编码，这是一种比较特殊的编码方式。</p>

<p>对于int32类型的数字，一般需要4个byte 来表示。但是采用 Varint，对于很小的int32 类型的数字，则可以用 1个byte来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。
Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：<code>1010 1100 0000 0010</code>
下图演示了 Google Protocol Buffer 如何解析两个 bytes。注意到最终计算前将两个 byte 的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用 little-endian 的方式。</p>

<p><img src="/images/20151231/pb-varint.png" alt="Varint编码图" /></p>

<p>对Varint编码了解后，前面<code>ReadTag</code>时就是这样来判断结束条件的。但是大家有没有疑问，就是前面说的Tag(也叫Key)是按<code>field_num &lt;&lt; 3 | Wire_type</code>生成的，这里field_num左移3位会不会导致数据丢失呢？这里就假设field_num是uint32类型的，左移3位依然能表示2^28个，相信在一个message里不会达到这么多字段吧，因此完全够用。而且对Tag进行Varint编码的是<code>field_num &lt;&lt; 3 | Wire_type</code>这个结果。</p>

<h2 id="section">题外篇</h2>

<p>对于在proto描述文件中添加<code>option optimize_for = LITE_RUNTIM</code>到底有什么用呢？</p>

<p>当添加后在编译proto文件时编译器会使用<code>libprotobuf-lite</code>库而不是<code>libprotobuf</code>库，使用<code>libprotobuf-lite</code>我们的message生成的类会继承自<code>MessageLite</code>，如果使用<code>libprotobuf</code>，生成的类则继承自<code>Message</code>。然后<code>Message</code>又继承自<code>MessageLite</code>，并且添加了descriptor和reflection特性，这会导致生成的头文件中有支持这两个特性的相关代码，然后我们日常使用pb时根本用不到这两个特性，因此完全没有必要保留着他们。这也是为什么添加这个优化选项的原因了。对于这两个特性有什么功能大家可以自己去探索下。</p>

<p>这个原来是内部分享时写的，去除了部分内容，希望对于想要学习Pb的同学有所帮助。Pb的确是很优秀的序列化方法，值得深入研究学习。基于Pb也可以创造其他的一些工具，数据存储等方案。</p>

<blockquote>
  <p>本文是删减版本，如果有什么不清楚的地方，请留言进一步沟通。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>2015总结</title>
      <link href="http://mrmign.github.io/2015/12/31/2015-zong-jie/"/>
      <pubDate>2015-12-31T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/31/2015-zong-jie</guid>
      <content:encoded><![CDATA[<p>2016年的1月1日马上就要到来了，过去的几年每当到这个时候就会看到各种年底总结新年寄望。看着他们的一篇篇总结与新一年的奋斗目标，心里也说不出什么感觉。写出新的一年奋斗目标的那些同学现在已经当上CEO，迎娶了白富美，走上人生巅峰了吧。鉴于此，我也要为了同样的目标对今年做个总结，为明年树立个目标。</p>

<p>2015.4拿到毕业证正式入职鹅厂，这不知不觉就过完了9个月，到了年末。入职后在原来团队待了2个来月就到了新的团队，不过在新团队氛围还是挺不错的。在今年主要是熟悉业务逻辑，了解老的代码，然后做新需求，小组内做了3次分享，但是都是kpi之外的，根据当时的需要自愿分享的。</p>

<p>一个是关于iOS的私有API的分享，关于私有API在去年的时候就开始研究了，不过当时由于对一些底层知识如<code>Mach-O</code>了解不多，没能深入的把工具做好，只是当时就针对特定APP进行了扫描，而且结果也不是很理想，现在也底层知识有了相对比较全面的了解了，又没有时间去搞这一块了，这次分享也基本是把之前做的一些研究给小组同学普及了一下，进行过越狱开发的基本也都有所涉及。说到私有API，就得提下越狱开发，今年7月左右买了逆向开发的第二版书，计算全面地学习下逆向工程的，可是今年过完了书也没有完全看完，逆向过的应用也只有几款，而且都是简单的功能（去广告）逆向，再复杂点的就没有搞了，这些没有完成的目标都是由于自己的拖延导致的，<strong>2016年克服的第一大问题就是拖延</strong>。逆向的知识还是要继续学习的，尝试逆向更复杂的功能。刚开始学习的时候就想着最后能否自己写个抢红包插件，看来今年要呵呵了。。。虽然网上有人写了Android版本的，但是iOS的木有啊，自己动手，丰衣足食。还是要学习。关于逆向，今年下半年了解了很多逆向相关的工具，有些开源的也要去研究学习下，如<code>MobileSubstrate</code>这个最基本的，<code>Cycript</code>。代码还是要多看，多写。</p>

<p>第二个就是学习了下<code>JSPatch</code>的实现，然后与小组成员一起分享学习了下。<code>JSPatch</code>是一个动态替换应用内方法的框架。代码1400多行，不多，从最初的方案到现在的方案，作者也是花了很多功夫，踩了不少坑的。实现原理充分利用了Objective-C的<code>Runtime</code>特性，对于学习理解Runtime也是很有帮助的。JSPatch实现的出发点很好，利用<code>JavaScriptCore.framework</code>这个iOS系统本身提供的库，不像那些使用Wax框架的还是自己添加解析器，管理运行环境等。<code>JSPatch</code>让我有了一个想法，就是在越狱开发上基于<code>JSPatch</code>可以搭建一个工具平台，因为它本身就是用来动态替换App内的方法的，越狱写的<code>Tweak</code>也是同样的来替换原来的方法，但是需要编译安装，如果通过JavaScript来实现就不需要提前编译，这样的工具与越狱平台上的<code>Flex</code>非常像，但是对于Flex的实现原理还没有研究，也不太清楚它下载的那些插件是什么格式的。但是如果基于JSPatch，插件必定是用JS写的。该想法目前还没有付诸实施。希望2016能够实现此想法。</p>

<p>鉴于上面说的两点，私有API和越狱开发是分不开的，越狱开发特别是针对系统应用来开发Tweak，肯定要搞清楚系统的API，这里就不泛大量私有API。而对于第三方应用进行越狱开发，也要对于应用的类有所了解才行，但是随着iOS系统的升级，苹果也一直在修复系统漏洞，加强系统安全，有时dump应用的头文件已经不那么好使了。但是，应用要运行起来必须要加载到内存中必须要解密后才可以正常运行，因此通过动态方法可以比较容易得到应用内的类，就像<code>RuntimeBrowser</code>提供的功能一样，我们可以对它进行改造，做成一个动态库，每当应用运行起来后就可以dump内部的类，根据<code>RuntimeBroser</code>的做法，可进一步做出类的关系图，将继承关系，协议的Confirm关系通过图的形式表现出来，就可以清晰的表示出来了。更完美的是可以进行模糊查找某些类的关系图。</p>

<p>第三个就是关于Protobuf的分享，虽然之前一直在用，但是一直没有研究它的工作原理，为什么会这么优秀。通过本次分享对它的格式及原理都有了了解。而且在查资料的过程中也发现了很多基于pb的其他的优秀工具，可见pb的工作原理是非常优秀的。下一步还要更多研究下相关内容，希望能把代码完整的看一遍。</p>

<p>上面三点是主要做的一些事情，其他的时间就要还是在做需求相关的工作，接触消息相关逻辑，期间也做了第一款动画效果，也花费了些时间去学习了解，说到这里还有两个话题需要分享，一个是消息逻辑，另一个是动画相关知识分享。</p>

<p>走入社会也要不断学习呀，今年买了几本书，但是都还没有看完，其中有几本是非技术相关的，《沟通的艺术》、《学会提问》、《人性的弱点》都只是翻了一部分，技术书倒是读了一些，主要是iOS相关的，因为苹果去年也发布了新的编程语言Swift，虽然去年抽空学习了下，由于工作中主要还是Objective-C，长时间不用也就淡忘了，今年都发布2.0了，又重新学习了下，对比起来代码真的少好多，希望在新的一年里也能用Swift来写款小软件吧。技术书方面希望接下来能把那几本经典的都再读一遍，《iOS X Pushing The Limit6，7》,iOS的设计模式，官方文档多读，非技术书方面希望把今年没读完的先读完，然后再读些心理学方面的东西。</p>

<p>本来写这篇年末总结的时候是想着一气呵成的，竟然又拖拖拉拉的3天假期才写完，而且前后衔接不连贯，先这样吧，第一次写这样的总结，越写越流利的（自我安慰下~）。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Swift学习笔记5</title>
      <link href="http://mrmign.github.io/2015/12/14/swift-xue-xi-bi-ji-5/"/>
      <pubDate>2015-12-14T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/14/swift-xue-xi-bi-ji-5</guid>
      <content:encoded><![CDATA[<h2 id="memory-management">Memory Management</h2>

<h3 id="weak-reference">Weak Reference</h3>

<ul>
  <li>only an <code>Optional</code> reference can be marked as weak.</li>
  <li>the reference must be a <code>var</code> reference.</li>
</ul>

<p>对于循环引用的情况，只需要其中一者是weak的就可以，规则</p>

<blockquote>
  <p>The one that is not the “owner” will have a weak reference to its “owner”.</p>
</blockquote>

<h3 id="unowned-reference">Unowned Reference</h3>

<p>该引用在下面的例子中特别有用，如果一个对象没有对其他对象的引用就不能存在，但是这个引用又不需要一直存在。 就像人与小狗，小狗必须有主人，但是人不一定有小狗。
可以把小狗的主人声明为<code>unowned</code>.</p>

<p>Unowned reference可以是Optional也可以是let的。但是用unowned是有风险的，有可能后面访问对象时为空。</p>

<p>只有对类类型的引用才能声明为<code>weak</code>或<code>unowned</code>。</p>

<h3 id="weakunowned">匿名函数中的weak与unowned引用</h3>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">FunctionHolder</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">function</span> <span class="p">:</span> <span class="p">(</span><span class="n">Void</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span><span class="o">?</span>
<a name="True-3"></a>    <span class="k">deinit</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;deinit&quot;</span><span class="p">)</span>
<a name="True-5"></a>    <span class="p">}</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="k">func</span> <span class="n">testFunctionHolder</span><span class="p">()</span> <span class="p">{</span>
<a name="True-8"></a>    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">FunctionHolder</span><span class="p">()</span>
<a name="True-9"></a>    <span class="n">f</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
<a name="True-10"></a>        <span class="p">[</span><span class="k">weak</span> <span class="n">f</span><span class="p">]</span> <span class="k">in</span>
<a name="True-11"></a>        <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<a name="True-12"></a>    <span class="p">}</span>
<a name="True-13"></a><span class="p">}</span></code></pre></div>
<p>传入匿名函数的引用是Optional的，通常是进行一个weak-strong转换</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">FunctionHolder</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">function</span> <span class="p">:</span> <span class="p">(</span><span class="n">Void</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span><span class="o">?</span>
<a name="True-3"></a>    <span class="k">deinit</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;deinit&quot;</span><span class="p">)</span>
<a name="True-5"></a>    <span class="p">}</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="k">func</span> <span class="n">testFunctionHolder</span><span class="p">()</span> <span class="p">{</span>
<a name="True-8"></a>    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">FunctionHolder</span><span class="p">()</span>
<a name="True-9"></a>    <span class="n">f</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
<a name="True-10"></a>        <span class="p">[</span><span class="k">weak</span> <span class="n">f</span><span class="p">]</span> <span class="k">in</span> <span class="c1">//weak</span>
<a name="True-11"></a>        <span class="n">guard</span> <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
<a name="True-12"></a>        <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1">//strong</span>
<a name="True-13"></a>    <span class="p">}</span>
<a name="True-14"></a><span class="p">}</span></code></pre></div>
<p><code>unowned</code>用的最多的场景还是针对<code>self</code>引用的情况。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="nl">MyDropBounceAndRollBehavior</span> <span class="p">:</span> <span class="bp">UIDynamicBehavior</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">let</span> <span class="nl">v</span> <span class="p">:</span> <span class="bp">UIView</span>
<a name="True-3"></a>    <span class="k">init</span><span class="p">(</span><span class="n">view</span> <span class="nl">v</span><span class="p">:</span><span class="bp">UIView</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="nb">self</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">v</span>
<a name="True-5"></a>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
<a name="True-6"></a>    <span class="p">}</span>
<a name="True-7"></a>    <span class="kr">override</span> <span class="k">func</span> <span class="n">willMoveToAnimator</span><span class="p">(</span><span class="nl">dynamicAnimator</span><span class="p">:</span> <span class="bp">UIDynamicAnimator</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
<a name="True-8"></a>        <span class="k">if</span> <span class="n">dynamicAnimator</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
<a name="True-9"></a>        <span class="k">let</span> <span class="n">sup</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">superview</span><span class="o">!</span>
<a name="True-10"></a>        <span class="k">let</span> <span class="n">grav</span> <span class="o">=</span> <span class="bp">UIGravityBehavior</span><span class="p">()</span>
<a name="True-11"></a>        <span class="n">grav</span><span class="p">.</span><span class="n">action</span> <span class="o">=</span> <span class="p">{</span>
<a name="True-12"></a>            <span class="p">[</span><span class="kr">unowned</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span>
<a name="True-13"></a>            <span class="k">let</span> <span class="n">items</span> <span class="o">=</span> <span class="n">dynamicAnimator</span><span class="o">?</span><span class="p">.</span><span class="n">itemsInRect</span><span class="p">(</span><span class="n">sup</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span> <span class="kt">as</span><span class="o">!</span> <span class="p">[</span><span class="bp">UIView</span><span class="p">]</span>
<a name="True-14"></a>            <span class="k">if</span> <span class="n">items</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
<a name="True-15"></a>                <span class="n">dynamicAnimator</span><span class="o">?</span><span class="p">.</span><span class="n">removeBehavior</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
<a name="True-16"></a>                <span class="nb">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
<a name="True-17"></a>            <span class="p">}</span>
<a name="True-18"></a>        <span class="p">}</span>
<a name="True-19"></a>        <span class="nb">self</span><span class="p">.</span><span class="n">addChildBehavior</span><span class="p">(</span><span class="n">grav</span><span class="p">)</span>
<a name="True-20"></a>        <span class="n">grav</span><span class="p">.</span><span class="n">addItem</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">v</span><span class="p">)</span>
<a name="True-21"></a>    <span class="p">}</span>
<a name="True-22"></a><span class="p">}</span></code></pre></div>
<p>对于协议类型的引用只有当它是类协议(<strong>标记为@objc或class</strong>)的时候才可以声明<code>weak</code>或<code>unowned</code></p>

<p>Obejctive-C中声明的协议已经隐式标记为@objc，因此是类协议。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Swift学习笔记4</title>
      <link href="http://mrmign.github.io/2015/12/14/swift-xue-xi-bi-ji-4/"/>
      <pubDate>2015-12-14T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/14/swift-xue-xi-bi-ji-4</guid>
      <content:encoded><![CDATA[<h2 id="extension">Extension</h2>

<p>Extension声明只能在文件的最顶层。也就是说不能嵌套在其他类型中声明。
<code>extension typeName [: protocols ] {}</code></p>

<p>限制：</p>

<ul>
  <li>extension不能重写已有的成员（但是你可以重载overload已有的方法）</li>
  <li>不能声明存储属性，但是可以声明计算属性</li>
  <li>类型的扩展不能声明designated initializer或deintializer,但是可以声明convenience initializer.</li>
</ul>

<p>扩展可以用来组织代码，可以将要实现的协议用扩展来实现。</p>

<p><strong>当扩展Swift的struct时，可以声明initializer,并且保留隐式的初始化方法</strong></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Digit</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">Int</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a>
<a name="True-5"></a><span class="k">extension</span> <span class="n">Digit</span> <span class="p">{</span>
<a name="True-6"></a>    <span class="k">init</span><span class="p">()</span> <span class="p">{</span>
<a name="True-7"></a>        <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">num</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<a name="True-8"></a>    <span class="p">}</span>
<a name="True-9"></a><span class="p">}</span></code></pre></div>
<h3 id="extending-protocols">Extending Protocols</h3>

<p>当扩展协议时，你可以为协议添加方法和属性，跟协议声明不同，这些方法和属性不是必须要被adopter实现的。他们是真实的方法和属性，会被实现该协议的类型继承。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a><span class="p">}</span>
<a name="True-3"></a><span class="k">extension</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-4"></a>    <span class="k">func</span> <span class="n">fly</span><span class="p">()</span> <span class="p">{</span>
<a name="True-5"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;flap flap flap&quot;</span><span class="p">)</span>
<a name="True-6"></a>    <span class="p">}</span>
<a name="True-7"></a><span class="p">}</span>
<a name="True-8"></a><span class="k">struct</span> <span class="nl">Bird</span><span class="p">:</span><span class="n">Flier</span> <span class="p">{</span>
<a name="True-9"></a><span class="p">}</span>
<a name="True-10"></a><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Bird</span><span class="p">()</span>
<a name="True-11"></a><span class="n">b</span><span class="p">.</span><span class="n">fly</span><span class="p">()</span> <span class="c1">//flap flap flap</span>
<a name="True-12"></a>
<a name="True-13"></a><span class="k">struct</span> <span class="nl">Insect</span> <span class="p">:</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-14"></a>    <span class="k">func</span> <span class="n">fly</span><span class="p">()</span> <span class="p">{</span>
<a name="True-15"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;whirr&quot;</span><span class="p">)</span>
<a name="True-16"></a>    <span class="p">}</span>
<a name="True-17"></a><span class="p">}</span>
<a name="True-18"></a><span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Insect</span><span class="p">()</span>
<a name="True-19"></a><span class="n">i</span><span class="p">.</span><span class="n">fly</span><span class="p">()</span> <span class="c1">// whirr</span></code></pre></div>
<p><strong>Warning: 这种继承不是多态的</strong> adopter的实现不是重写，它是另一个实现。
如果要让它像多态继承，必须在原始的protocol中声明为必须实现的方法。</p>

<h3 id="extending-generics">Extending Generics</h3>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">extension</span> <span class="n">Array</span> <span class="k">where</span> <span class="nl">Element</span><span class="p">:</span><span class="n">Comparable</span> <span class="p">{</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<h2 id="umbrella-types">Umbrella Types</h2>

<h3 id="anyobject">AnyObject</h3>

<p>它实际上是一个protocol,它有特殊特征，所有的类类型都自动conform to it.</p>

<p><code>AnyObject</code>是swift版本的<code>id</code></p>

<h3 id="anyclass">AnyClass</h3>

<h3 id="any">Any</h3>

<blockquote>
  <p>The <code>Any</code> type is a type alias for an empty protocol that is automatically adopted by all types.</p>

</blockquote>

<h2 id="error">Error</h2>

<p>在Swift中，an error必须实现<code>ErrorType</code>协议的对象，它只有一个string的<code>_domain</code>和一个Int的<code>_code</code>属性。</p>

<p>错误机制有两个阶段需要考虑：</p>

<ul>
  <li>throwing an error.会打断当前的执行路径，会将一个错误对象丢给错误处理机制</li>
  <li>catching an error. 捕获错误异常做出响应，代码继续在捕获的地方执行。</li>
</ul>

<p>只能在下面两处地方<code>throw</code>:</p>

<ul>
  <li>In the do block of a <code>do...catch</code> construct</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">do</span> <span class="p">{</span>
<a name="True-2"></a><span class="p">...</span> <span class="c1">//throw can happen here</span>
<a name="True-3"></a><span class="p">}</span> <span class="n">catch</span> <span class="n">errortype</span> <span class="p">{</span>
<a name="True-4"></a><span class="p">..</span>
<a name="True-5"></a><span class="p">}</span> <span class="n">catch</span> <span class="p">{</span>
<a name="True-6"></a><span class="p">..</span>
<a name="True-7"></a><span class="p">}</span></code></pre></div><ul>
  <li>In a function marked <code>throws</code></li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">enum</span> <span class="nl">NotLongEnough</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">case</span> <span class="n">ISaidLongMeantLong</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">func</span> <span class="n">giveMeALongStinrg</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="p">{</span>
<a name="True-5"></a>    <span class="k">if</span> <span class="n">s</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
<a name="True-6"></a>        <span class="n">throw</span> <span class="n">NotLongEnough</span><span class="p">.</span><span class="n">ISaidLongMeantLong</span>
<a name="True-7"></a>    <span class="p">}</span>
<a name="True-8"></a>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;thanks for the string&quot;</span><span class="p">)</span>
<a name="True-9"></a><span class="p">}</span></code></pre></div>
<p>在函数声明中添加<code>throws</code>会创建一个新的函数类型。
上面函数giveMeALongStinrg的类型不是（String）-&gt;()而是String）throws -&gt;()</p>

<p>对于调用有throws的函数也有要求：调用者在函数前必须加<code>try</code>。</p>

<blockquote>
  <p>A function called with <code>try</code> can throw. 也就是说这里的try跟throw是一样的，因此必须在do..catch块或是标记为throws的函数中。</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">stringTest</span><span class="p">()</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">do</span> <span class="p">{</span>
<a name="True-3"></a>        <span class="n">try</span> <span class="n">giveMeALongStinrg</span><span class="p">(</span><span class="s">&quot;is this long enough&quot;</span><span class="p">)</span>
<a name="True-4"></a>    <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span>
<a name="True-5"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;I guess it wasn&#39;t long enough&quot;</span><span class="p">)</span>
<a name="True-6"></a>    <span class="p">}</span>
<a name="True-7"></a><span class="p">}</span></code></pre></div>
<p>如果你非常确定一个函数可以throw但实际上没有throw,你可以调用时用<code>try!</code>来代替<code>try</code>,可以在任意地方使用<code>try!</code>,这样就不需要捕获可能的异常了。但是如果你错了就可能导致程序crash</p>

<p>在<code>try</code>与<code>try!</code>之间的是<code>try?</code>,你可以在任意地方使用<code>try?</code>而不需要捕获异常。但是，如果有异常抛出不会crash，它会返回nil。因此当表达式有返回值的时候<code>try?</code>非常适用。如果没有异常抛出，返回结果会是Optional。</p>

<h2 id="defer">Defer</h2>

<blockquote>
  <p>The purpose of the defer statement is to ensure that a certain block of code will be executed at the time of the path of execution flows out of the current scope, no matter how.</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">doSomethingTimeConsuming</span><span class="p">()</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">beginIgnoreInteractionEvents</span><span class="p">()</span>
<a name="True-3"></a>    <span class="n">defer</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">endIgnoreInteractionEvents</span><span class="p">()</span>
<a name="True-5"></a>    <span class="p">}</span>
<a name="True-6"></a>    <span class="c1">// ... do stuff...</span>
<a name="True-7"></a>    <span class="k">if</span> <span class="n">someThingHappend</span> <span class="p">{</span>
<a name="True-8"></a>        <span class="k">return</span> 
<a name="True-9"></a>    <span class="p">}</span>
<a name="True-10"></a>    <span class="c1">// ... do more stuff</span>
<a name="True-11"></a><span class="p">}</span></code></pre></div>
<p><code>defer</code>语句的作用就是不管执行过程中发生了什么，都会执行defer语句块代码。
比较常见的例子，读写文件时如果中间发生错误， 要关闭文件句柄，就可以通过defer实现。</p>

<p>如果当前范围内有多个defer块，将会按照他们出现顺序的逆序执行。实际上是有一个defer栈，每一个后续的defer块都放在栈顶，要执行defer块时，依次从醉顶取出并执行。</p>

<h2 id="aborting">Aborting</h2>

<p>故意地让程序崩溃。</p>

<p>一种方式就是用全局函数<code>fatalError</code>实现。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="n">required</span> <span class="k">init</span><span class="o">?</span><span class="p">(</span><span class="n">coer</span> <span class="nl">aDecoder</span><span class="p">:</span> <span class="bp">NSCoder</span><span class="p">)</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="n">fatalError</span><span class="p">(</span><span class="s">&quot;init(coder:) has not been implemented&quot;</span><span class="p">)</span>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<p>包含<code>fatalError</code>的初始化方法没必要初始化任何属性，因为 <code>fatalError</code>是用<code>@noreturn</code>属性声明的。</p>

<p>有返回值的函数当遇到<code>fatalError</code>调用的时候不用返回值。</p>

<h2 id="guard">Guard</h2>

<blockquote>
  <p>A guard statement is an if statement where you must exit early in response to failure of the condition.</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="n">guard</span> <span class="n">condition</span> <span class="k">else</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="n">statements</span>
<a name="True-3"></a>    <span class="n">exit</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p>The <strong><code>else</code></strong> block must jump out of the current scope.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="n">guard</span> <span class="k">case</span> <span class="k">let</span> <span class="p">.</span><span class="n">Number</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">err</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span><span class="p">}</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="c1">// ... some optional</span>
<a name="True-4"></a><span class="n">guard</span> <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="k">else</span> <span class="p">{</span><span class="k">return</span><span class="p">}</span> <span class="c1">//compile error</span></code></pre></div>
<p>上面代码编译不过是因为<code>guard let</code>跟<code>if let</code>，<code>while let</code>不一样，它声明的变量范围不是嵌套。</p>

<h2 id="operators">Operators</h2>

<ul>
  <li>infix (默认的，可省略)</li>
  <li>prefix</li>
  <li>postfix</li>
</ul>

<p>操作符声明和对应的函数声明必须在文件的最顶层(top level of a file)</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="kr">infix</span> <span class="kr">operator</span> <span class="o">^^</span> <span class="p">{}</span>
<a name="True-2"></a><span class="k">func</span> <span class="o">^^</span><span class="p">(</span><span class="nl">lhs</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">rhs</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
<a name="True-3"></a>    <span class="k">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">lhs</span>
<a name="True-4"></a>    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span> <span class="p">..</span><span class="o">&lt;</span><span class="n">rhs</span> <span class="p">{</span> <span class="n">result</span> <span class="o">*=</span> <span class="n">lhs</span><span class="p">}</span>
<a name="True-5"></a>    <span class="k">return</span> <span class="n">result</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>当定义操作符时，如果你要考虑在表达式中该操作符与其他操作符的优先级顺序你要添加<code>precedence</code>和<code>associativity</code>说明。</p>

<h2 id="privacy">Privacy</h2>

<ul>
  <li>internal 默认地，在module内可见</li>
  <li>private 只在被包含的文件可见，在文件层级</li>
  <li>public</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Swift学习笔记3</title>
      <link href="http://mrmign.github.io/2015/12/13/swift-xue-xi-bi-ji-3/"/>
      <pubDate>2015-12-13T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/13/swift-xue-xi-bi-ji-3</guid>
      <content:encoded><![CDATA[<h2 id="casting">Casting</h2>

<p>用<code>as!</code>进行转换时可能会出错，可以先用<code>is</code>进行判断，然后再转。另一种方法就是用<code>as?</code>来转，结果是Optional的。</p>

<h2 id="type-reference">Type Reference</h2>

<p>实例可以通过<code>dynamicType</code>方法来获取它的类型。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">class</span> <span class="k">var</span> <span class="nl">whatDogSay</span><span class="p">:</span><span class="n">String</span> <span class="p">{</span>
<a name="True-3"></a>        <span class="k">return</span> <span class="s">&quot;woof&quot;</span>
<a name="True-4"></a>    <span class="p">}</span>
<a name="True-5"></a>    <span class="n">fun</span> <span class="n">bark</span><span class="p">()</span> <span class="p">{</span>
<a name="True-6"></a>        <span class="n">print</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="kt">dynamicType</span><span class="p">.</span><span class="n">whatDogSay</span><span class="p">)</span>
<a name="True-7"></a>    <span class="p">}</span>
<a name="True-8"></a><span class="p">}</span></code></pre></div><p>用<code>dynaimicType</code>而不是硬编码用爆大锅是因为它遵循多态。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="n">dogMakerAndNamer</span><span class="p">(</span><span class="nl">whattye</span><span class="p">:</span><span class="n">Dog</span><span class="p">.</span><span class="kt">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">whattype</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Fido&quot;</span><span class="p">)</span>
<a name="True-3"></a>    <span class="k">return</span> <span class="n">d</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p>因为这里不确定是否Dog的每个子类型都实现了init(name:)初始化方法，因此会编译失败。 为了保证每个类型都有<code>init(name:)</code>初始化方法，我们需要添加<code>required</code>关键字。</p>

<h3 id="type-self">Type <code>Self</code></h3>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">name</span> <span class="p">:</span> <span class="n">String</span>
<a name="True-3"></a>    <span class="n">required</span> <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<a name="True-5"></a>    <span class="p">}</span>
<a name="True-6"></a>    <span class="k">class</span> <span class="n">fun</span> <span class="n">makeAndName</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Self</span> <span class="p">{</span>
<a name="True-7"></a>        <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Fido&quot;</span><span class="p">)</span>
<a name="True-8"></a>        <span class="k">return</span> <span class="n">d</span>
<a name="True-9"></a>    <span class="p">}</span>
<a name="True-10"></a><span class="p">}</span>
<a name="True-11"></a>
<a name="True-12"></a><span class="k">class</span> <span class="nl">NoisyDog</span><span class="p">:</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-13"></a><span class="p">}</span></code></pre></div>
<ul>
  <li><code>.dynamicType</code> sent to an instance</li>
  <li><code>.Type</code> sent to a type</li>
  <li><code>.self</code> sent to a type: the type.如果需要Dog.Type, 可以传Dog.self</li>
  <li><code>self</code> 在实例代码中表示实例；在静态或类代码中表示这个类型</li>
  <li><code>Self</code> 在方法声明中，指定返回类型</li>
</ul>

<h2 id="protocols">Protocols</h2>

<blockquote>
  <p>A protocol is an object type, but there are no protocol objects.</p>
</blockquote>

<p>一个对象类型实现了一个协议也就是实现了协议中的属性和方法。</p>

<blockquote>
  <p>Any type — enum, struct, class, another protocol—can adopt protocol.</p>
</blockquote>

<p>swift中最有用的一个协议就是<code>CustomStringConvertible</code>, 该协议要求我们实现<code>description</code>属性。</p>

<h3 id="declaring-a-protocol">Declaring a protocol</h3>

<p>协议声明只能在文件的最顶层。协议可以包含：</p>

<ul>
  <li>Properties. 协议中的属性声明用<code>var</code>, name, type {get} 或者 {get set}。如果是{get}，实现协议的属性也可以是writable,如果是{get set}，实现协议的属性就不能是保读的。用static声明static/class属性，类实现者可以实现为class属性，也可以是static的。</li>
  <li>Methods. 协议中方法的声明没有方法体，没有{}。用static声明static/class方法，类实现时可以实现为class方法。
    <ul>
      <li>如果enum/struct实现的方法需要声明为<code>mutating</code>，协议必须指定<code>mutating</code>。如果协议没有指定，实现者不能添加<code>mutating</code></li>
      <li>如果协议有指定<code>mutating</code>,实现者可以省略</li>
    </ul>
  </li>
  <li>Type alias.</li>
  <li>Protocol adoption.</li>
</ul>

<h3 id="optional-protocol-members">Optional Protocol Members</h3>

<p>在声明协议为<code>@objc</code>时，Swfit允许有可选的协议成员。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="p">@</span><span class="n">objc</span> <span class="k">protocol</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="n">optional</span> <span class="k">var</span> <span class="nl">song</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span><span class="kr">get</span><span class="p">}</span>
<a name="True-3"></a>    <span class="n">optioanl</span> <span class="k">func</span> <span class="n">sing</span><span class="p">()</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p>只有类能实现这样的协议，而且该特性只有在类是<code>NSObject</code>的子类时才管用，或者是可选的成员标识为<code>@objc</code></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="nl">Bird</span> <span class="p">:</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="p">@</span><span class="n">objc</span> <span class="k">func</span> <span class="n">sing</span><span class="p">()</span> <span class="p">{</span>
<a name="True-3"></a>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;tweet&quot;</span><span class="p">)</span>
<a name="True-4"></a>    <span class="p">}</span>
<a name="True-5"></a><span class="p">}</span></code></pre></div>
<p><strong>如果可选方法有返回值，返回类型是Optional的</strong></p>

<h3 id="class-protocol">Class Protocol</h3>

<blockquote>
  <p>A protoco declared with keyword <code>class</code> after the colon after its name is a <em>class protocol</em> ,meanig that it can be adopted only by class object type.</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="nl">SecondViewControllerDelegate</span><span class="p">:</span> <span class="k">class</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">func</span> <span class="n">acceptData</span><span class="p">(</span><span class="nl">data</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">!</span><span class="p">)</span>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<p>如果协议已经标记为<code>@objc</code>就没必要再声明class，<code>@objc</code>也暗示这是个类协议。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="nl">SecondViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">weak</span> <span class="k">var</span> <span class="nl">delegate</span> <span class="p">:</span> <span class="n">SecondViewControllerDelegate</span><span class="o">?</span>
<a name="True-3"></a>    <span class="p">...</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p>只有类实例才会有特殊的内存管理。</p>

<h3 id="implicitly-required-initializer">Implicitly Required Initializer</h3>

<blockquote>
  <p>An initializer declared in a protocol is implicitly required, and the class is forced to make that requirement explicit.</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Flier</span> <span class="p">}</span>
<a name="True-2"></a>    <span class="k">init</span><span class="p">()</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">class</span> <span class="nl">Bird</span> <span class="p">:</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-5"></a>    <span class="n">required</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>如果Bird标记为<code>final</code>就没有必要把<code>init</code>标记为<code>required</code></p>

<h2 id="generics">Generics</h2>

<p>在编译时确定真正的类型。</p>

<h3 id="generic-declaration">Generic declaration</h3>

<ul>
  <li>Generic protocol with Self.在协议中，用<code>Self</code>把协议变成一个generic.<code>Self</code>是实现协议的类型。如下面的协议，如果是<code>Bird</code>实现了该协议，在实现<code>flockTogetherWith</code>方法时需要声明参数类型为<code>Bird</code>。</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">func</span> <span class="n">flockTogetherWith</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="kt">Self</span><span class="p">)</span>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<ul>
  <li>Generic protocol with empty type alias.协议可以声明一个type alias但不指定代表什么类型，也就是没有包含赋值符号，这样就把协议变成了generic。实现协议的要声明一个具体的类型</li>
  <li>Generic functions.</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="n">take</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span>
<a name="True-2"></a><span class="p">{</span>
<a name="True-3"></a>    <span class="k">return</span> <span class="n">t</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<ul>
  <li>Generic object types</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Something</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">first</span><span class="p">:</span> <span class="n">T</span>
<a name="True-3"></a>    <span class="k">var</span> <span class="nl">second</span><span class="p">:</span> <span class="n">T</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<h3 id="type-constraints">Type Constraints</h3>

<blockquote>
  <p>You can limit the types that eligible to be used for resolving a particular placeholder. 
The simplest form of type constraint is to <strong>put a colon and type name after the placeholder’s name</strong> when it first appears.</p>
</blockquote>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">typealias</span> <span class="nl">Other</span> <span class="p">:</span> <span class="n">Flier</span>
<a name="True-3"></a>    <span class="k">func</span> <span class="n">flockTogetherWith</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="n">Other</span><span class="p">)</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p>上面的代码是不合法的，protocol不能用自己作为类型限制。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Superfiler</span> <span class="p">{}</span>
<a name="True-2"></a><span class="k">protocol</span> <span class="nl">Flier</span> <span class="p">:</span> <span class="n">Superflier</span> <span class="p">{</span>
<a name="True-3"></a>    <span class="k">typealias</span> <span class="nl">Other</span> <span class="p">:</span> <span class="n">Superflier</span>
<a name="True-4"></a>    <span class="k">func</span> <span class="n">flockTogetherWith</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="n">Other</span><span class="p">)</span>
<a name="True-5"></a><span class="p">}</span></code></pre></div>
<p>上面通过声明另一个protocol，让Flier adopt,并且限制Other为该Protocol。</p>

<h3 id="explicit-specialization">Explicit Specialization</h3>

<h4 id="generic-protocol-with-associated-type">Generic protocol with associated type</h4>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">typealias</span> <span class="n">Other</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">struct</span> <span class="nl">Bird</span><span class="p">:</span> <span class="n">Flier</span> <span class="p">{</span>
<a name="True-5"></a>    <span class="k">typealias</span> <span class="n">Other</span> <span class="o">=</span> <span class="n">String</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<h4 id="generic-object-type">Generic object type</h4>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">name</span> <span class="p">:</span> <span class="n">T</span><span class="o">?</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
<a name="True-5"></a>
<a name="True-6"></a><span class="k">class</span> <span class="n">NoisyDog</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">Dog</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<a name="True-7"></a>
<a name="True-8"></a><span class="k">class</span> <span class="nl">NoisyDog</span> <span class="p">:</span> <span class="n">Dog</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre></div>
<h2 id="associated-type-chain">Associated Type Chain</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">protocol</span> <span class="n">Wieldable</span> <span class="p">{}</span>
<a name="True-2"></a><span class="k">struct</span> <span class="nl">Sword</span> <span class="p">:</span> <span class="n">Wieldable</span> <span class="p">{}</span>
<a name="True-3"></a><span class="k">struct</span> <span class="nl">Bow</span> <span class="p">:</span> <span class="n">Wieldable</span> <span class="p">{}</span>
<a name="True-4"></a>
<a name="True-5"></a><span class="k">protocol</span> <span class="n">Superfighter</span> <span class="p">{</span>
<a name="True-6"></a>    <span class="k">typealias</span> <span class="nl">Weapon</span> <span class="p">:</span> <span class="n">Wieldable</span>
<a name="True-7"></a><span class="p">}</span>
<a name="True-8"></a><span class="k">protocol</span> <span class="nl">Fighter</span> <span class="p">:</span> <span class="n">Superfighter</span> <span class="p">{</span>
<a name="True-9"></a>    <span class="k">typealias</span> <span class="nl">Enemy</span> <span class="p">:</span> <span class="n">Superfighter</span>
<a name="True-10"></a>    <span class="k">func</span> <span class="n">steal</span><span class="p">(</span><span class="nl">weapon</span><span class="p">:</span><span class="kt">Self</span><span class="p">.</span><span class="n">Enemy</span><span class="p">.</span><span class="n">Weapon</span><span class="p">,</span> <span class="nl">from</span><span class="p">:</span><span class="kt">Self</span><span class="p">.</span><span class="n">Enemy</span><span class="p">)</span>
<a name="True-11"></a><span class="p">}</span>
<a name="True-12"></a><span class="k">struct</span> <span class="nl">Soldier</span> <span class="p">:</span> <span class="n">Fighter</span> <span class="p">{</span>
<a name="True-13"></a>    <span class="k">typealias</span> <span class="n">Weapon</span> <span class="o">=</span> <span class="n">Sword</span>
<a name="True-14"></a>    <span class="k">typealias</span> <span class="n">Enemy</span> <span class="o">=</span> <span class="n">Archer</span>
<a name="True-15"></a>    <span class="k">func</span> <span class="n">steal</span><span class="p">(</span><span class="nl">weapon</span><span class="p">:</span><span class="n">Bow</span><span class="p">,</span> <span class="nl">from</span><span class="p">:</span><span class="n">Archer</span><span class="p">)</span> <span class="p">{</span>
<a name="True-16"></a>    <span class="p">}</span>
<a name="True-17"></a><span class="p">}</span>
<a name="True-18"></a><span class="k">struct</span> <span class="nl">Archer</span> <span class="p">:</span> <span class="n">Fighter</span> <span class="p">{</span>
<a name="True-19"></a>    <span class="k">typealias</span> <span class="n">Weapon</span> <span class="o">=</span> <span class="n">Bow</span>
<a name="True-20"></a>    <span class="k">typealias</span> <span class="n">Enemy</span> <span class="o">=</span> <span class="n">Soldier</span>
<a name="True-21"></a>    <span class="k">func</span> <span class="n">steal</span><span class="p">(</span><span class="nl">weapon</span><span class="p">:</span> <span class="n">Sword</span><span class="p">,</span> <span class="nl">from</span><span class="p">:</span><span class="n">Soldier</span><span class="p">)</span> <span class="p">{</span>
<a name="True-22"></a>    <span class="p">}</span>
<a name="True-23"></a><span class="p">}</span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>swift学习笔记-2</title>
      <link href="http://mrmign.github.io/2015/12/07/swift-xue-xi-bi-ji-2/"/>
      <pubDate>2015-12-07T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/07/swift-xue-xi-bi-ji-2</guid>
      <content:encoded><![CDATA[<h1 id="object-types">Object Types</h1>

<p>函数参数可以有默认值</p>

<p><strong>property必须在声明时或是在初始化方法中被初始化</strong></p>

<h2 id="referring-to-self">Referring to self</h2>

<p>在实例属性没有初始化完成前，初始化方法不能显式或隐匿的引用self(An initializer may not refer to self, explicitly or implicitly, until all instance properties have been initialized).</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Cat</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
<a name="True-3"></a>	<span class="k">var</span> <span class="nl">license</span><span class="p">:</span> <span class="n">Int</span>
<a name="True-4"></a>	<span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">license</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<a name="True-6"></a>		<span class="n">meow</span><span class="p">()</span> <span class="c1">//compile error</span>
<a name="True-7"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">license</span> <span class="o">=</span> <span class="n">license</span>
<a name="True-8"></a>	<span class="p">}</span>
<a name="True-9"></a>	<span class="k">func</span> <span class="n">meow</span><span class="p">()</span> <span class="p">{</span>
<a name="True-10"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;meow&quot;</span><span class="p">)</span>
<a name="True-11"></a>	<span class="p">}</span>
<a name="True-12"></a><span class="p">}</span></code></pre></div>
<h2 id="delegating-initializer">Delegating initializer</h2>

<p>An intializer that calls another initializer is called a delegating initializer.</p>

<p>A delegating initailzer cannot set an immutable property(a <code>let</code> variable).因为只有在调用了其他初始化方法后才能引用属性，这个时候实例已经完全初始化了，已经无法再初始化let的属性了。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Digit</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">var</span> <span class="nl">number</span><span class="p">:</span> <span class="n">Int</span>
<a name="True-3"></a>	<span class="k">var</span> <span class="nl">meaningOfLife</span><span class="p">:</span> <span class="n">Bool</span>
<a name="True-4"></a>	<span class="c1">//let meaningOfLife :Bool</span>
<a name="True-5"></a>	<span class="k">init</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<a name="True-6"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span>
<a name="True-7"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">meaningOfLife</span> <span class="o">=</span> <span class="nb">false</span>
<a name="True-8"></a>	<span class="p">}</span>
<a name="True-9"></a>	<span class="k">init</span><span class="p">()</span> <span class="p">{</span>
<a name="True-10"></a>		<span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span><span class="mi">43</span><span class="p">)</span>
<a name="True-11"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">mearningOfLife</span> <span class="o">=</span> <span class="nb">true</span> <span class="c1">//如果meaningOfLife声明为let这里就编译错误了</span>
<a name="True-12"></a>	<span class="p">}</span>
<a name="True-13"></a><span class="p">}</span></code></pre></div>
<h2 id="failable-initailizer">Failable initailizer</h2>

<p>有可能返回nil的初始化方法。An initializer can return an Optional wrapping the new instance.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="n">calss</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">let</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
<a name="True-3"></a>	<span class="k">let</span> <span class="nl">license</span><span class="p">:</span> <span class="n">Int</span>
<a name="True-4"></a>	<span class="k">init</span><span class="o">!</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">license</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<a name="True-6"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">license</span> <span class="o">=</span> <span class="n">license</span>
<a name="True-7"></a>		<span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span>
<a name="True-8"></a>			<span class="k">return</span> <span class="nb">nil</span>
<a name="True-9"></a>		<span class="p">}</span>
<a name="True-10"></a>		<span class="k">if</span> <span class="n">license</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
<a name="True-11"></a>			<span class="k">return</span> <span class="nb">nil</span>
<a name="True-12"></a>		<span class="p">}</span>
<a name="True-13"></a>	<span class="p">}</span>
<a name="True-14"></a><span class="p">}</span></code></pre></div>
<p>上面的返回值是<code>Dog!</code>, the Optional is implicitly unwrapped.
可以直接使用返回的结果，但是如果返回nil， 直接使用就会导致crash</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">let</span> <span class="n">fido</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nl">license</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<a name="True-2"></a><span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">fido</span><span class="p">.</span><span class="n">name</span> <span class="c1">//crash</span></code></pre></div>
<p><code>UIImage</code>的初始化方法<code>init?(named:)</code>也是failable initializer,它没有implicitly unwrapped,所以返回是<code>UIImage?</code>,在使用前必须unwrapped.</p>

<h2 id="properties">Properties</h2>

<ul>
  <li>有固定的类型</li>
  <li>可以是var或let</li>
  <li>可以是stored或computed</li>
  <li>可以有setter observer</li>
  <li>实例属性可以声明为lazy</li>
</ul>

<p>存储型(stored)的实例属性必须有初始值(可以在声明时赋，也可以在初始化方法中赋值)。在属性初始化时不会调用Setter observer。</p>

<p><strong>初始化属性的代码不能获取实例属性也不能调用实例方法</strong>，因为会显式或隐匿的引用到<code>self</code>，但是在初始化时还没有<code>self</code>。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Moi</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="s">&quot;mat&quot;</span>
<a name="True-3"></a>	<span class="k">let</span> <span class="n">last</span> <span class="o">=</span> <span class="s">&quot;Nur&quot;</span>
<a name="True-4"></a>	<span class="k">let</span> <span class="n">whole</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="n">last</span> <span class="c1">//compile error</span>
<a name="True-5"></a>	<span class="k">let</span> <span class="nl">who</span> <span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="c1">//改用计算型的</span>
<a name="True-6"></a>		<span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="n">last</span>
<a name="True-7"></a>	<span class="p">}</span>
<a name="True-8"></a>	<span class="n">lazy</span> <span class="k">var</span> <span class="nl">who2</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="n">last</span>
<a name="True-9"></a><span class="p">}</span></code></pre></div>
<p>上面在初始化时访问了其他属性导致编译错误，可以改为用计算型的，因为计算型的不会真正计算直到<code>self</code>存在。</p>

<p>另外，还可以通过声明whole为lazy来解决。同样只有在self存在的时候才执行。</p>

<p>同样，计算型的和lazy的可以调用实例方法。</p>

<p>属性的初始化方法可以有多行代码，你可以定义执行匿名函数。如果代码有访问其他的属性或是实例方法，必须声明为<code>lazy</code></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Moi</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="s">&quot;mat&quot;</span>
<a name="True-3"></a>	<span class="k">let</span> <span class="n">last</span> <span class="o">=</span> <span class="s">&quot;Nur&quot;</span>
<a name="True-4"></a>	<span class="n">lazy</span> <span class="k">var</span> <span class="nl">whole2</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
<a name="True-5"></a>        <span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">first</span>
<a name="True-6"></a>        <span class="n">s</span><span class="p">.</span><span class="n">appendContentsOf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)</span>
<a name="True-7"></a>        <span class="n">s</span><span class="p">.</span><span class="n">appendContentsOf</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">last</span><span class="p">)</span>
<a name="True-8"></a>        <span class="k">return</span> <span class="n">s</span>
<a name="True-9"></a>    <span class="p">}()</span>
<a name="True-10"></a><span class="p">}</span></code></pre></div>
<p>静态属性初始化时可以引用其他静态属性，因为静态属性的初始化是<code>lazy</code>的。</p>

<h2 id="methods">Methods</h2>

<p>静态方法和类方法是通过<code>type</code>来访问的，<code>self</code>也就是type.</p>

<p>静态方法和类方法不能引用实例，因为根本就没有实例。因此静态方法和类方法不能直接引用任何实例属性和调用实例方法。反过来，实例方法可以访问静态属性和类属性，同样也可以调用静态方法和类方法。</p>

<h4 id="section">关于实例方法的一个私密</h4>

<p><strong>实例方法实际上是静态/类方法</strong></p>

<p>下面的代码是合法的</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">MyClass</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
<a name="True-3"></a>	<span class="k">func</span> <span class="n">store</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
<a name="True-5"></a>	<span class="p">}</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<a name="True-8"></a><span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></code></pre></div>
<p><code>store</code>是一个实例方法，但是可以按类方法的方式来调用，参数是该类的一个实例。</p>

<p>原因是<strong>An instance method is actually a curried static/class method composed of two functions - one function that takes an instance, and another function that takes the parameters of the instance method.</strong></p>

<p>因此，上面代码执行后<code>f</code>是第二种函数，can be called as a way of passing a parameter to the <code>store</code> method of the instance <code>m</code>.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="n">f</span><span class="p">(</span><span class="s">&quot;howdy&quot;</span><span class="p">)</span>
<a name="True-2"></a><span class="n">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">s</span><span class="p">)</span> <span class="c1">//howdy</span></code></pre></div>
<h2 id="enums">Enums</h2>

<p>可以用<code>rawValue:</code>的实例化方法来初始化有初始值的enum.<code>let type = Filter(rawValue:"Album")</code>,因为这里给的raw value可能没有对应的case,因此这是个failable initializer,返回值是Optional的。</p>

<h3 id="enum-property">Enum Property</h3>

<p>enum可以有实例属性和静态属性，但是enum的实例属性不能是存储型的(stored),因为如果相同case的两个实例如果存储了不同的实例属性值，它们就不再相同了。computed的属性是可以的。</p>

<h2 id="struct">Struct</h2>

<p>自动会有一个无参的<code>init()</code>,但是如果显式地添加了你自己的初始化方法，就不能再访问<code>init()</code>了，但是可以添加<code>init()</code>方法。</p>

<p>如果结构体有存储型属性但是没有显式的初始化方法，就会有一个根据实例属性衍生来的隐式初始化方法。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Digit</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">var</span> <span class="nl">number</span> <span class="p">:</span> <span class="n">Int</span>
<a name="True-3"></a>	<span class="k">var</span> <span class="nl">str</span> <span class="p">:</span> <span class="n">String</span>
<a name="True-4"></a><span class="p">}</span>
<a name="True-5"></a>
<a name="True-6"></a><span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Digit</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="nl">str</span><span class="p">:</span><span class="s">&quot;strut&quot;</span><span class="p">)</span></code></pre></div>
<p>如果实例方法要设置属性值，该方法必须标识为<code>mutating</code>,调用该方法的实例必须是<code>var</code>类型的。</p>

<h3 id="struct-as-namespace">Struct As Namespace</h3>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Default</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">static</span> <span class="k">let</span> <span class="n">Rows</span> <span class="o">=</span> <span class="s">&quot;Rows&quot;</span>
<a name="True-3"></a>	<span class="k">static</span> <span class="k">let</span> <span class="n">Columns</span> <span class="o">=</span> <span class="s">&quot;Columns&quot;</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
<p><strong>many Objective-C enums are bridged to Swift as this kind of Struct</strong></p>

<h2 id="classes">Classes</h2>

<p>在Objective-C中，类是唯一的对象类型。Some built-in Swift struct are magically bridged to Objective-C class types, <strong>but your custom struct types dont’t have that magic.</strong> 这也是在与OC和Cocoa交互时，声明类而不是结构体的主要原因。</p>

<p><strong>递归引用</strong></p>

<p>值类型与引用类型的区别：值类型不能结构上递归，也就是值类型的实例属性不能是相同类型的实例，如下代码就会编译失败</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">puppy</span> <span class="p">:</span> <span class="n">Dog</span><span class="o">?</span>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<p>In Swift 2.0 an enum case’s associated value can be an instance of that enum, provided the case( or the entire enum)is marked <code>indirect</code></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">enum</span> <span class="n">Node</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">case</span> <span class="n">None</span><span class="p">(</span><span class="n">Int</span><span class="p">)</span>
<a name="True-3"></a>    <span class="n">indirect</span> <span class="k">case</span> <span class="n">Left</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
<a name="True-4"></a>    <span class="n">indirect</span> <span class="k">case</span> <span class="n">Right</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
<a name="True-5"></a>    <span class="n">indirect</span> <span class="k">case</span> <span class="n">Both</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>子类可以继承父类的属性，也可以添加自己的属性，也可覆盖继承来的属性。</p>

<ul>
  <li><strong>通过<code>final</code>声明类可以阻止子类继承自该类。</strong></li>
  <li><strong>同样也可以用<code>final</code>防止类成员被子类重写</strong></li>
</ul>

<h3 id="class-initializer">Class Initializer</h3>

<ul>
  <li>Implicit initializer.如果一个类没有存储属性，亦或存储属性在声明时就初始化了，并且没有显式的初始化方法，就会有一个隐匿的初始化方法<code>init()</code></li>
  <li>Designated initializer.如果一个类有存储属性并且在声明时没有进行初始化，该类必须至少有一个designated initializer，当类初始化的时候所有的存储属性必须被初始化了。</li>
  <li>Convenience initializer.用<code>convenience</code>修饰。必须有<code>self.init(...)</code>调用。在当前类中，必须调用一个designated initializer或是调用另一个convenience初始化方法。</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">var</span> <span class="nl">name</span> <span class="p">:</span> <span class="n">String</span>
<a name="True-3"></a>	<span class="k">var</span> <span class="nl">license</span> <span class="p">:</span> <span class="n">Int</span>
<a name="True-4"></a>	<span class="n">inti</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">license</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<a name="True-6"></a>		<span class="nb">self</span><span class="p">.</span><span class="n">license</span> <span class="o">=</span> <span class="n">license</span>
<a name="True-7"></a>	<span class="p">}</span>
<a name="True-8"></a>	<span class="n">convenience</span> <span class="k">init</span><span class="p">(</span><span class="nl">license</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<a name="True-9"></a>		<span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Fido&quot;</span><span class="p">,</span> <span class="nl">license</span><span class="p">:</span><span class="n">license</span><span class="p">)</span>
<a name="True-10"></a>	<span class="p">}</span>
<a name="True-11"></a>	<span class="n">convenience</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span>
<a name="True-12"></a>		<span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">license</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span>
<a name="True-13"></a>	<span class="p">}</span>
<a name="True-14"></a><span class="p">}</span></code></pre></div>
<h3 id="subclass-initializer">Subclass initializer</h3>

<ul>
  <li>No declared initializer. 初始化方法由父类继承来的组成</li>
  <li>Convenience initializer only.</li>
  <li>Designated initializer. <strong>不再有继承的初始化方法了！</strong>显式的designated initializer 阻止了初始化方法的继承。现在子类有的唯一的初始化方法就是显式定义的。子类的designated initializer必须做下面的事:
    <ol>
      <li>必须保证子类所有的属性被初始化</li>
      <li>必须调用<code>super.init(...)</code>，而且该方法必须是父类的designated initializer</li>
      <li>然后才能使用<code>self</code>来调用实例方法，或访问继承来的属性。</li>
    </ol>
  </li>
</ul>

<h3 id="override-initializer">Override initializer</h3>

<ul>
  <li>如果子类初始化方法的签名与父类的convenience初始化方法相同，必须也是convenience的，并且不要标识<code>override</code></li>
  <li>如果子类初始化方法的签名与父类的designated初始化方法相同，可以是designated或是convenience初始化方法，并且必须标识为<code>override</code></li>
</ul>

<h3 id="failable-initializer">Failable initializer</h3>

<p>A failable initializer that returns an implicitly umwrapped Optional(<code>init!</code>) is treated just like a normal initializer(<code>init</code>) for purpose of overriding and delegation.对于返回<code>init?</code>的failable initializer,有其他的限制：</p>

<ul>
  <li><code>init</code>可以重写<code>init?</code>，反过来不行</li>
  <li><code>init?</code>可以调用<code>init</code></li>
  <li><code>init</code>可以通过<code>init</code>来调用<code>init?</code>，将返回结果解包</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="nl">A</span><span class="p">:</span><span class="bp">NSObject</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">init</span><span class="o">?</span><span class="p">(</span><span class="nl">ok</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
<a name="True-3"></a>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">()</span> <span class="c1">// init? call init</span>
<a name="True-4"></a>    <span class="p">}</span>
<a name="True-5"></a><span class="p">}</span>
<a name="True-6"></a><span class="k">class</span> <span class="nl">B</span><span class="p">:</span><span class="n">A</span> <span class="p">{</span>
<a name="True-7"></a>    <span class="kr">override</span> <span class="k">init</span><span class="p">(</span><span class="nl">ok</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// init override init?</span>
<a name="True-8"></a>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">ok</span><span class="p">:</span><span class="n">ok</span><span class="p">)</span><span class="o">!</span>   <span class="c1">// init call init? using &quot;!&quot;</span>
<a name="True-9"></a>    <span class="p">}</span>
<a name="True-10"></a><span class="p">}</span></code></pre></div>
<h3 id="required-intializer">Required intializer</h3>

<p>如果初始化方法标识为<code>required</code>,子类不能少了该初始化方法。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
<a name="True-3"></a>    <span class="n">required</span> <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
<a name="True-5"></a>    <span class="p">}</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="k">class</span> <span class="nl">NosiyDog</span><span class="p">:</span><span class="n">Dog</span> <span class="p">{</span>
<a name="True-8"></a>    <span class="k">var</span> <span class="n">obedient</span> <span class="o">=</span> <span class="nb">false</span>
<a name="True-9"></a>    <span class="k">init</span><span class="p">(</span><span class="nl">obedient</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
<a name="True-10"></a>        <span class="nb">self</span><span class="p">.</span><span class="n">obedient</span> <span class="o">=</span> <span class="n">obedient</span>
<a name="True-11"></a>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Fido&quot;</span><span class="p">)</span>
<a name="True-12"></a>    <span class="p">}</span>
<a name="True-13"></a>    <span class="n">required</span> <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<a name="True-14"></a>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">name</span><span class="p">)</span>
<a name="True-15"></a>    <span class="p">}</span>
<a name="True-16"></a><span class="p">}</span></code></pre></div>
<p>从上面代码中看到我们重写的required初始化方法没有标识为<code>override</code>，但是标识为了<code>required</code>,因此可以保证该要求可以一直往子类传。</p>

<h3 id="class-deinitializer">Class Deinitializer</h3>

<p>方法名是<code>deinit</code>。如果一个类有父类，子类的deinitializer方法先调用，再调用父类的。</p>

<h2 id="class-properties-and-methods">Class Properties and Methods</h2>

<p>子类可以重写继承的属性，但是必须与要继承的属性有相同的名字和类型，并且必须标识为<code>override</code>。</p>

<ul>
  <li>如果父类属性是可写的(存储属性或是有setter方法的计算属性），子类的重写可以为属性添加setter observer</li>
  <li>子类可以重写为计算属性，但是：
    <ul>
      <li>如果父类是存储属性，子类重写为计算属性必须同时有getter和setter方法</li>
      <li>如果父类属性是计算的，子类重写的计算属性必须重新实现所有父类的accessors。如果父类的属性是只读的(只有getter方法)，子类重写可以添加setter方法。</li>
    </ul>
  </li>
</ul>

<p>重写的属性的方法可以用<code>super</code>来访问被继承的属性。</p>

<p><code>static</code>和<code>class</code>成员都会被子类继承，并且也是<code>static</code>或是<code>class</code>成员。</p>

<p><strong>从程序员角度看<code>static</code>方法与<code>class</code>方法的主要不同是static方法不能重写。</strong></p>

<p>静态属性与类属性之间的区别也差不多，非常明显的就是静态属性可以是stored,类属性只能是computed.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">class</span> <span class="n">Dog</span> <span class="p">{</span>
<a name="True-2"></a>    <span class="k">class</span> <span class="k">var</span> <span class="nl">whatDogSay</span> <span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
<a name="True-3"></a>        <span class="k">return</span> <span class="s">&quot;woof&quot;</span>
<a name="True-4"></a>    <span class="p">}</span>
<a name="True-5"></a>    <span class="k">func</span> <span class="n">bark</span> <span class="p">()</span> <span class="p">{</span>
<a name="True-6"></a>        <span class="n">print</span><span class="p">(</span><span class="n">Dog</span><span class="p">.</span><span class="n">whatDogSay</span><span class="p">)</span>
<a name="True-7"></a>    <span class="p">}</span>
<a name="True-8"></a><span class="p">}</span>
<a name="True-9"></a>
<a name="True-10"></a><span class="n">calss</span> <span class="nl">NosiyDog</span> <span class="p">:</span><span class="n">Dog</span> <span class="p">{</span>
<a name="True-11"></a>    <span class="kr">override</span> <span class="k">static</span> <span class="k">var</span> <span class="nl">whatDogSay</span> <span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
<a name="True-12"></a>        <span class="k">return</span> <span class="s">&quot;WOOF&quot;</span>
<a name="True-13"></a>    <span class="p">}</span>
<a name="True-14"></a><span class="p">}</span></code></pre></div>
<p>上面代码中子类继承了<code>whatDogSay</code>并且重写为类属性或是静态属性。<strong>但是即使重写为static类型的，也不能是存储属性。</strong></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>swift学习笔记</title>
      <link href="http://mrmign.github.io/2015/12/01/swift-xue-xi-bi-ji/"/>
      <pubDate>2015-12-01T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/12/01/swift-xue-xi-bi-ji</guid>
      <content:encoded><![CDATA[<p>Swift有三种类型的对象: class, struct, enum</p>

<h2 id="function-parameters-and-return-value">Function Parameters and Return Value</h2>

<p><code>Void</code>(函数没有返回值时返回的类型)在Swift中是真实的类型，没有返回任何值的函数实际返回的就是Void类型,也可以用()来表示。
<code>return Void</code>,<code>return ()</code>,<code>return</code> 是一个效果。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="p">{}</span>
<a name="True-2"></a><span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{}</span>
<a name="True-3"></a><span class="k">func</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span></code></pre></div><p>上面三个方法都是没有返回值的。</p>

<h4 id="function-signature">函数签名(Function Signature)</h4>

<p>利用参数与返回值确定函数签名，例如<code>(Int, Int) -&gt; Int</code>。对于没有参数与返回值的函数可以用<code>Void -&gt; Void</code>,<code>() -&gt; ()</code>, <code>Void -&gt; ()</code>, <code>() -&gt; Void</code>表示，为了一致，还是优先使用前两种。</p>

<h2 id="external-parameter-names">External Parameter Names</h2>

<p>作用：</p>

<ul>
  <li>声明每个参数的目的</li>
  <li>区分函数。两个函数名字和签名可以相同，但是外部参数名不能相同</li>
  <li>帮助Swift与OC，Cocoa交互</li>
</ul>

<p><strong>除了第一个参数，剩下的所有的参数默认自动是外部参数。</strong></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{}</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="c1">//调用</span>
<a name="True-4"></a><span class="n">say</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span></code></pre></div>
<p>如果不想要外部参数，在前面加<code>_</code>,像下面这样：</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">_</span> <span class="nl">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{}</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="c1">//调用</span>
<a name="True-4"></a><span class="n">say</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></code></pre></div>
<p>一个Swift函数的名字是括号前面的名字加上外部参数的名字，如上面的<code>say(_:times:)</code>和<code>say(_:_:)</code>。</p>

<h2 id="overloading">Overloading</h2>

<p>两个函数如果有相同的signature但是外部参数名字不同不能说是重载；因为他们外部参数名称不同，因此他们是两个函数名不相同的函数。</p>

<h2 id="default-parameter-values">Default Parameter Values</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span></code></pre></div><p>可以用<code>say("hi")</code>和<code>say("hi", times:3)</code>来调用该函数。</p>

<h2 id="ignored-parameters">Ignored Parameters</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="n">loudly</span> <span class="nl">_</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span> <span class="p">{}</span>
<a name="True-2"></a><span class="c1">//调用</span>
<a name="True-3"></a><span class="n">say</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span><span class="nl">times</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="nb">true</span><span class="p">)</span>
<a name="True-4"></a>
<a name="True-5"></a><span class="k">func</span> <span class="n">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="nl">_</span><span class="p">:</span><span class="n">Int</span><span class="p">){}</span>
<a name="True-6"></a><span class="c1">//调用</span>
<a name="True-7"></a><span class="n">say</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span></code></pre></div>
<p>当参数局部名称是<code>_</code>时在函数体内无法读取该参数值。</p>

<h2 id="modifiable-parameter">Modifiable Parameter</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">say</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="nl">times</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span> <span class="k">var</span> <span class="nl">loudly</span><span class="p">:</span> <span class="n">Bool</span><span class="p">){}</span></code></pre></div><p>默认情况下函数参数隐式声明为常量(<code>let</code>),不能进行赋值。如果需要在函数体中对参数进行赋值，需要显式声明为<code>var</code>。虽然声明为var后可以进行赋值，但是不能修改函数体外部原来的值。如果要修改传递参数的原始的值，可以按下面操作：</p>

<ol>
  <li>把想要修改的参数声明为<code>inout</code></li>
  <li>在调用函数时，想让函数修改其值的变量必须声明为<code>var</code></li>
  <li>不要用变量来当参数，需要传递它的地址，在变量名前加<code>&amp;</code></li>
</ol>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">removeFromeString</span><span class="p">(</span><span class="k">inout</span> <span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">character</span> <span class="nl">c</span><span class="p">:</span><span class="n">Character</span><span class="p">){}</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
<a name="True-4"></a><span class="n">removeFromString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">)</span></code></pre></div>
<h4 id="unsafemutablepointer"><code>UnsafeMutablePointer</code></h4>

<p>当需要与OC打交道而不是Swift时，需要使用<code>UnsafeMutablePointer </code>而不是<code>inout</code></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="n">CGRectDivide</span><span class="p">(</span><span class="nl">rect</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">,</span> <span class="n">_</span> <span class="nl">slice</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="bp">CGRect</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span> <span class="nl">remainder</span><span class="p">:</span> <span class="n">UnsafeMutablePointer</span><span class="o">&lt;</span><span class="bp">CGRect</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span> <span class="nl">amount</span><span class="p">:</span> <span class="n">CGFloat</span><span class="p">,</span> <span class="n">_</span> <span class="nl">edge</span><span class="p">:</span> <span class="bp">CGRectEdge</span><span class="p">)</span>
<a name="True-2"></a>
<a name="True-3"></a><span class="k">var</span> <span class="n">arrow</span> <span class="o">=</span> <span class="n">CGRectZero</span>
<a name="True-4"></a><span class="k">var</span> <span class="n">body</span> <span class="o">=</span> <span class="n">CGRectZero</span>
<a name="True-5"></a><span class="n">CGRectDivide</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arrow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">,</span> <span class="n">Arrow</span><span class="p">.</span><span class="n">ARHEIGHT</span><span class="p">,</span> <span class="p">.</span><span class="n">MinYEdge</span><span class="p">)</span></code></pre></div>
<p>当参数是class类型时，不需要声明为<code>inout</code>,因为class类型是引用类型的，其他的都是值类型。</p>

<h2 id="function-as-value">Function As Value</h2>

<p>函数要作为值需要有类型，函数的类型就是它的signature.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">doThis</span><span class="p">(</span><span class="nl">f</span><span class="p">:()</span><span class="o">-&gt;</span><span class="p">())</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="n">f</span><span class="p">()</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">func</span> <span class="nf">whatTodo</span><span class="p">()</span> <span class="p">{</span>
<a name="True-5"></a>	<span class="n">print</span><span class="p">(</span><span class="s">&quot;I did it&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">}</span>
<a name="True-7"></a><span class="n">doThis</span><span class="p">(</span><span class="n">whatTodo</span><span class="p">)</span></code></pre></div>
<p>可以使用<code>typealis</code>给某个函数类型一个名字，如<code>typealias VoidVoidFunc = () -&gt; ()</code></p>

<h2 id="anonymous-functions">Anonymous Functions</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">f</span><span class="p">(</span><span class="nl">finished</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a>
<a name="True-5"></a><span class="p">{</span>
<a name="True-6"></a>	<span class="p">(</span><span class="nl">finished</span><span class="p">:</span><span class="n">Bool</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">in</span>
<a name="True-7"></a>	<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-8"></a><span class="p">}</span></code></pre></div>
<h5 id="section">匿名函数的使用：</h5>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="p">()</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">in</span>
<a name="True-3"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-4"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="p">(</span><span class="nl">finished</span><span class="p">:</span> <span class="n">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="k">in</span>
<a name="True-6"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-7"></a><span class="p">})</span></code></pre></div>
<p>省略返回值</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="p">()</span> <span class="k">in</span>
<a name="True-3"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-4"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="p">(</span><span class="nl">finished</span><span class="p">:</span> <span class="n">Bool</span><span class="p">)</span> <span class="k">in</span>
<a name="True-6"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-7"></a><span class="p">})</span></code></pre></div>
<p>当没有参数时省略<code>in</code>行</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="p">(</span><span class="nl">finished</span><span class="p">:</span> <span class="n">Bool</span><span class="p">)</span> <span class="k">in</span>
<a name="True-5"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">})</span></code></pre></div>
<p>省略参数类型</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="k">in</span>
<a name="True-5"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">})</span></code></pre></div>
<p>省略括号</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="n">finished</span> <span class="k">in</span>
<a name="True-5"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">})</span></code></pre></div>
<p>即使有参数也省略<code>in</code>行。如果返回值可以省略，并且如果编译器知道参数类型，你可以省略in行，在匿名函数体内直接用$0,$1,..引用对应的参数。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\($0)&quot;</span><span class="p">)</span>
<a name="True-5"></a><span class="p">})</span></code></pre></div>
<p>省略参数的名字。如果匿名函数体不需要引用参数，可以用<code>_</code>在in行替换参数列表，如果不需要引用任何参数，可以只用一个<code>_</code>来替换整个参数列表。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
<a name="True-4"></a>		<span class="n">_</span> <span class="k">in</span>
<a name="True-5"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">})</span></code></pre></div>
<p><strong>不能同时省略in行也不通过magic name引用参数！！</strong></p>

<p>省略函数参数名。如果在调用函数时匿名函数作为最后一个参数，可以在倒数第二个参数闭合函数，将没有名称的匿名函数紧跟在后面。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="bp">UIView</span><span class="p">.</span><span class="n">animationWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="nb">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span>
<a name="True-3"></a>	<span class="p">}){</span>
<a name="True-4"></a>		<span class="n">_</span> <span class="k">in</span>
<a name="True-5"></a>		<span class="n">print</span><span class="p">(</span><span class="s">&quot;finished:\(finished)&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>省略调用函数的括号。如果你用了尾函数语法，并且你调用的函数只有一个函数作为参数，你可以在调用时省略空括号。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">doThis</span><span class="p">(</span><span class="nl">f</span><span class="p">:()</span><span class="o">-&gt;</span><span class="p">())</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="n">f</span><span class="p">()</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="n">doThis</span> <span class="p">{</span>
<a name="True-5"></a>	<span class="n">print</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">)</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>省略关键字return</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">sayHi</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">return</span> <span class="s">&quot;Hi&quot;</span>
<a name="True-3"></a><span class="p">}</span>
<a name="True-4"></a><span class="k">func</span> <span class="n">performAndPrint</span><span class="p">(</span><span class="nl">f</span><span class="p">:()</span><span class="o">-&gt;</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>	<span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
<a name="True-6"></a>	<span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<a name="True-7"></a><span class="p">}</span>
<a name="True-8"></a><span class="n">performAndPrint</span> <span class="p">{</span>
<a name="True-9"></a>	<span class="n">sayHi</span><span class="p">()</span>
<a name="True-10"></a><span class="p">}</span></code></pre></div>
<h2 id="closure">Closure</h2>

<p>Swift函数就是闭包。</p>

<h2 id="curried-functions">Curried Functions（柯里化函数）</h2>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">makeRoundedRectangleMaker</span><span class="p">(</span><span class="nl">sz</span><span class="p">:</span><span class="bp">CGSize</span><span class="p">,</span> <span class="n">_</span> <span class="nl">r</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">UIImage</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">return</span> <span class="p">{</span>
<a name="True-3"></a>		<span class="n">imageOfSize</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
<a name="True-4"></a>			<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span>
<a name="True-5"></a>				<span class="nl">rounderRect</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span><span class="n">CGPointZero</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="n">sz</span><span class="p">),</span>
<a name="True-6"></a>				<span class="nl">cornerRadius</span><span class="p">:</span><span class="n">r</span><span class="p">)</span>
<a name="True-7"></a>			<span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>
<a name="True-8"></a>		<span class="p">}</span>
<a name="True-9"></a>	<span class="p">}</span>
<a name="True-10"></a><span class="p">}</span>
<a name="True-11"></a>
<a name="True-12"></a><span class="k">let</span> <span class="n">maker</span> <span class="o">=</span> <span class="n">makeRoundedRectangleMaker</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span><span class="mi">8</span><span class="p">)</span></code></pre></div>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">makeRoundedRectangleMaker</span><span class="p">(</span><span class="nl">sz</span><span class="p">:</span><span class="bp">CGSize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIImage</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">return</span> <span class="p">{</span>
<a name="True-3"></a>		<span class="n">r</span> <span class="k">in</span>
<a name="True-4"></a>		<span class="n">imageOfSize</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
<a name="True-5"></a>			<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span>
<a name="True-6"></a>				<span class="nl">rounderRect</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span><span class="n">CGPointZero</span><span class="p">,</span><span class="nl">size</span><span class="p">:</span> <span class="n">sz</span><span class="p">),</span>
<a name="True-7"></a>				<span class="nl">cornerRadius</span><span class="p">:</span><span class="n">r</span><span class="p">)</span>
<a name="True-8"></a>			<span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>
<a name="True-9"></a>		<span class="p">}</span>
<a name="True-10"></a>	<span class="p">}</span>
<a name="True-11"></a><span class="p">}</span>
<a name="True-12"></a>
<a name="True-13"></a><span class="k">let</span> <span class="n">maker</span> <span class="o">=</span> <span class="n">makeRoundedRectangleMaker</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<a name="True-14"></a><span class="k">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">maker</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span></code></pre></div>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">makeRoundedRectangleMaker</span><span class="p">(</span><span class="nl">sz</span><span class="p">:</span><span class="bp">CGSize</span><span class="p">)(</span><span class="n">_</span> <span class="nl">r</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UIImage</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">return</span> <span class="n">imageOfSize</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
<a name="True-3"></a>			<span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">UIBezierPath</span><span class="p">(</span>
<a name="True-4"></a>				<span class="nl">rounderRect</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span><span class="n">CGPointZero</span><span class="p">,</span> <span class="nl">size</span><span class="p">:</span> <span class="n">sz</span><span class="p">),</span>
<a name="True-5"></a>				<span class="nl">cornerRadius</span><span class="p">:</span><span class="n">r</span><span class="p">)</span>
<a name="True-6"></a>			<span class="n">p</span><span class="p">.</span><span class="n">stroke</span><span class="p">()</span>
<a name="True-7"></a>	<span class="p">}</span>
<a name="True-8"></a><span class="p">}</span>
<a name="True-9"></a>
<a name="True-10"></a><span class="k">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">makeRoundedRectangleMaker</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">20</span><span class="p">))(</span><span class="mi">8</span><span class="p">)</span></code></pre></div>
<h2 id="variable">Variable</h2>

<p>变量的类型不能改变。</p>

<h4 id="computed-initializer">Computed Initializer</h4>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">let</span> <span class="nl">timed</span> <span class="p">:</span> <span class="n">Bool</span> <span class="o">=</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
<a name="True-3"></a>		<span class="k">return</span> <span class="nb">true</span>
<a name="True-4"></a>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<a name="True-5"></a>		<span class="k">return</span> <span class="nb">false</span>
<a name="True-6"></a>	<span class="p">}</span>
<a name="True-7"></a><span class="p">}()</span></code></pre></div>
<p>定义并调用匿名函数通常是唯一合法的方式来计算实例属性的初始值。因为在初始化实例属性时不能调用实例的方法(此时还没有实例，你正在创建实例)。</p>

<h4 id="computed-variables">Computed Variables</h4>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">var</span> <span class="nl">now</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="kr">get</span> <span class="p">{</span>
<a name="True-3"></a>		<span class="k">return</span> <span class="bp">NSDate</span><span class="p">().</span><span class="n">description</span>
<a name="True-4"></a>	<span class="p">}</span>
<a name="True-5"></a>	<span class="kr">set</span> <span class="p">{</span>
<a name="True-6"></a>		<span class="n">print</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
<a name="True-7"></a>	<span class="p">}</span>
<a name="True-8"></a><span class="p">}</span></code></pre></div>
<p><strong>注意：</strong></p>

<ul>
  <li>变量必须声明为<code>var</code>，类型必须显式声明</li>
  <li>get 方法必须返回与变量类型一致的值</li>
  <li>setter就像是有一个参数的函数，参数的局部名称默认是<code>newValue</code>，也可以修改该参数的局部名称<code>set (val) {}</code></li>
  <li>setter函数不是必需的，如果省略setter，变量就变成只读的，如果尝试赋值会报编译错误。<strong>在swift中，一个没有setter的计算变量是创建一个只读变量的主要方式</strong></li>
  <li><strong>一定要有getter!!</strong>,如果没有setter, get及后面的{}可以省略。这也是只读变量的合法声明。</li>
</ul>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">var</span> <span class="nl">now</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="k">return</span> <span class="bp">NSDate</span><span class="p">().</span><span class="n">description</span>
<a name="True-3"></a><span class="p">}</span></code></pre></div>
<h4 id="setter-observer">Setter Observer</h4>

<p>与声明computed Variable类似。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;whatever&quot;</span> <span class="p">{</span>
<a name="True-2"></a>	<span class="kr">willSet</span> <span class="p">{</span>
<a name="True-3"></a>		<span class="n">print</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
<a name="True-4"></a>	<span class="p">}</span>
<a name="True-5"></a>	<span class="kr">didSet</span> <span class="p">{</span>
<a name="True-6"></a>		<span class="n">print</span><span class="p">(</span><span class="n">oldValue</span><span class="p">)</span>
<a name="True-7"></a>	<span class="p">}</span>
<a name="True-8"></a><span class="p">}</span></code></pre></div>
<p><strong>注意：</strong></p>

<ul>
  <li>变量必须是var,可以有初始值。</li>
  <li>默认情况下<code>willSet</code>接收新值，局部名为newValue，同样也可以改成其他名字</li>
  <li>默认情况下<code>didSet</code>接收旧的值，局部名为oldValue，同样也可以改为其他名字。新值已经存储了，在didSet里可以访问到，在didSet函数里修改为其他值也是合法的。</li>
</ul>

<p>Setter Observer函数在初始化或是在<code>didSet</code>里修改值时不会调用，否则会死循环！</p>

<p>Computed Variable不能有setter observer!</p>

<h4 id="lazy-initialization">Lazy Initialization</h4>

<p>swift中有三种类型可以initialized lazily:</p>

<ul>
  <li><strong>global variables</strong>. 自动lazy.全局变量的初始化是在第一次访问的时候进行的。通过<code>dispatch_once</code>进行保护，使初始化只进行一次且是线程安全的。</li>
  <li><strong>static properties</strong>. 静态属性行为与全局变量相似，原因也相同。(There are no stored class properties in Swift, so class properties can’t be initialized and thus can’t have lazy initialization.??这句是什么意思)</li>
  <li><strong>Instance properties</strong>. 实例属性默认不是lazy的，可以在声明时用<code>lazy</code>标记，属性必须声明为var不能是let。</li>
</ul>

<p>Lazy initialization通常用来实现单例。</p>

<h2 id="tuple">Tuple</h2>

<p>tuple当作函数参数传递时必须是常量。</p>

<h2 id="optional">Optional</h2>

<p><code>ImplicitlyUnwrappedOptional</code>,也是optional的，但是它的值可以直接用。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">func</span> <span class="nf">realStringExpecter</span><span class="p">(</span><span class="nl">s</span><span class="p">:</span><span class="n">String</span><span class="p">){}</span>
<a name="True-2"></a><span class="k">var</span> <span class="nl">str</span><span class="p">:</span> <span class="n">ImplicitlyUnwrappedOptional</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">&quot;how&quot;</span>
<a name="True-3"></a><span class="n">realStringExpecter</span><span class="p">(</span><span class="n">str</span><span class="p">)</span></code></pre></div>
<p><code>var str! = "how"</code> 效果一样</p>

<p><strong>An implicitly unwrapped optional is still an Optional !</strong></p>

<p>explicitly unwrapping an Optional contains nothing will crash!</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">var</span> <span class="nl">stringMaybe</span> <span class="p">:</span> <span class="n">String</span><span class="o">?</span>
<a name="True-2"></a><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stringMaybe</span><span class="o">!</span> <span class="c1">//crash</span></code></pre></div>
<h4 id="optional-chains">Optional Chains</h4>

<p>To send a message safely to an Optional that might be empty, you can unwrap the Optional optionally.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">var</span> <span class="nl">str</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
<a name="True-2"></a><span class="k">let</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">str</span><span class="o">?</span><span class="p">.</span><span class="n">uppercaseString</span></code></pre></div>
<p>If any of them is unwrapped optionally, the entire expression produces an Optional wrapping the type.</p>

<p>An assignment into an Optional chain with optional unwrapping returns an Optional wrapping <code>Void</code>.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><a name="True-1"></a><span class="k">let</span> <span class="nl">ok</span> <span class="p">:</span> <span class="n">Void</span> <span class="o">?</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">window</span><span class="o">?</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="bp">UIViewController</span><span class="p">()</span>
<a name="True-2"></a><span class="k">if</span> <span class="n">ok</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
<a name="True-3"></a>	<span class="c1">//it worked</span>
<a name="True-4"></a><span class="p">}</span></code></pre></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>JSPatch学习</title>
      <link href="http://mrmign.github.io/2015/09/21/jspatch-xue-xi/"/>
      <pubDate>2015-09-21T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/09/21/jspatch-xue-xi</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>iOS上播放消息提示音及振动总结</title>
      <link href="http://mrmign.github.io/2015/09/21/ios-shang-bo-fang-xiao-xi-ti-shi-yin-ji-zhen-dong-zong-jie/"/>
      <pubDate>2015-09-21T00:00:00+08:00</pubDate>
      <author>Arming</author>
      <guid>http://mrmign.github.io/2015/09/21/ios-shang-bo-fang-xiao-xi-ti-shi-yin-ji-zhen-dong-zong-jie</guid>
      <content:encoded><![CDATA[<p>在QQ，微信中当收到新消息的时候会播放提示音或是振动，亦或是声音+振动，如何在自己的应用中实现同样的功能呢？</p>

<h3 id="section">播放提示音</h3>

<p>当应用在前台运行收到消息时，这个时候要播放消息的提示音了，如何播放直接上代码：</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a><span class="cm">/* 播放完成回调 */</span>
<a name="True-2"></a><span class="kt">void</span> <span class="nf">AudioSoundPlayComplete</span><span class="p">(</span><span class="n">SystemSoundID</span> <span class="n">soundid</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">clientData</span><span class="p">)</span>
<a name="True-3"></a><span class="p">{</span>
<a name="True-4"></a>    <span class="n">AudioServicesRemoveSystemSoundCompletion</span><span class="p">(</span><span class="n">soundid</span><span class="p">);</span>
<a name="True-5"></a>    <span class="n">AudioServicesDisposeSystemSoundID</span><span class="p">(</span><span class="n">soundid</span><span class="p">);</span>
<a name="True-6"></a>    <span class="n">AlertSoundService</span> <span class="o">*</span><span class="n">alerService</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">AlertSoundService</span><span class="o">*</span><span class="p">)</span><span class="n">clientData</span><span class="p">;</span>
<a name="True-7"></a>    <span class="p">[</span><span class="n">alerService</span> <span class="nl">stopPlaySound</span><span class="p">:</span><span class="n">soundid</span><span class="p">];</span>
<a name="True-8"></a><span class="p">}</span>
<a name="True-9"></a>
<a name="True-10"></a><span class="p">-</span> <span class="p">(</span><span class="n">SystemSoundID</span><span class="p">)</span><span class="nf">playSound:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">soundName</span>
<a name="True-11"></a><span class="p">{</span>
<a name="True-12"></a>    <span class="n">SystemSoundID</span> <span class="n">ssid</span><span class="p">;</span>
<a name="True-13"></a>    <span class="bp">NSString</span><span class="o">*</span> <span class="n">pathName</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> 
<a name="True-14"></a>    <span class="n">pathName</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span><span class="nl">pathForResource</span><span class="p">:</span><span class="n">soundName</span> <span class="nl">ofType</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<a name="True-15"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">pathName</span><span class="p">)</span> <span class="p">{</span>
<a name="True-16"></a>        <span class="c1">//将NSString类型路径名转换为NSURL类型</span>
<a name="True-17"></a>        <span class="bp">NSURL</span><span class="o">*</span> <span class="n">pathUrl</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSURL</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initFileURLWithPath</span><span class="p">:</span><span class="n">pathName</span><span class="p">];</span>
<a name="True-18"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">pathUrl</span><span class="p">)</span> <span class="p">{</span>
<a name="True-19"></a>            <span class="n">OSStatus</span> <span class="n">err</span> <span class="o">=</span> <span class="n">AudioServicesCreateSystemSoundID</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFURLRef</span><span class="p">)</span><span class="n">pathUrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssid</span><span class="p">);</span>
<a name="True-20"></a>            <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">kAudioServicesNoError</span><span class="p">)</span> <span class="p">{</span>
<a name="True-21"></a>                <span class="n">AudioServicesAddSystemSoundCompletion</span><span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">AudioSoundPlayComplete</span><span class="p">,</span>  <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">);</span>
<a name="True-22"></a>                <span class="n">AudioServicesPlaySystemSound</span><span class="p">(</span><span class="n">ssid</span><span class="p">);</span>
<a name="True-23"></a>                <span class="k">return</span> <span class="n">ssid</span><span class="p">;</span>
<a name="True-24"></a>            <span class="p">}</span>
<a name="True-25"></a>            <span class="k">else</span>
<a name="True-26"></a>            <span class="p">{</span>
<a name="True-27"></a>                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;create system sound id fail,%s&quot;</span><span class="p">,</span><span class="n">__FUNCTION__</span><span class="p">);</span>
<a name="True-28"></a>                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="True-29"></a>            <span class="p">}</span>
<a name="True-30"></a>        <span class="p">}</span>
<a name="True-31"></a>        <span class="k">else</span>
<a name="True-32"></a>        <span class="p">{</span>
<a name="True-33"></a>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;path with NSString convert to path with NSURL fail!!!,%s&quot;</span><span class="p">,</span><span class="n">__FUNCTION__</span><span class="p">);</span>
<a name="True-34"></a>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="True-35"></a>        <span class="p">}</span>
<a name="True-36"></a>    <span class="p">}</span>
<a name="True-37"></a>    <span class="k">else</span>
<a name="True-38"></a>    <span class="p">{</span>
<a name="True-39"></a>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;the path for sound play is nil,%s&quot;</span><span class="p">,</span><span class="n">__FUNCTION__</span><span class="p">);</span>
<a name="True-40"></a>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="True-41"></a>    <span class="p">}</span>
<a name="True-42"></a><span class="p">}</span></code></pre></div>
<p>播放提示音是传入要播放的声音文件的名称，从bundle寻找对应文件找到了就进行播放，这里添加了系统声音播放完成后的回调，以便在声音播放结束后进行其他处理，比如如果需要根据不同的消息播放不同的提示音，如果当前正在播放提示音1，此时收到其他消息要播放提示音2，这里就不能简单的直接调用该方法进行播放了，我们需要一个播放队列，把要播放的提示音添加到队列中来处理，当播放完成一个后就需要从队列移除，此时播放完成的回调就派上用场了。</p>

<h3 id="section-1">振动</h3>

<p>如果要振动提示又该如何实现呢？系统为我们提供了振动的soundID <code>kSystemSoundID_Vibrate</code>，可以直接使用该soundID实现振动，代码如下:</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a><span class="kt">void</span> <span class="nf">VibratePlayComplete</span><span class="p">(</span><span class="n">SystemSoundID</span> <span class="n">soundId</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">clientData</span><span class="p">)</span>
<a name="True-2"></a><span class="p">{</span>
<a name="True-3"></a>    <span class="n">AudioServicesRemoveSystemSoundCompletion</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">);</span>
<a name="True-4"></a>    <span class="n">AudioServicesDisposeSystemSoundID</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">);</span>
<a name="True-5"></a><span class="p">}</span>
<a name="True-6"></a>
<a name="True-7"></a><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playVibrate</span>
<a name="True-8"></a><span class="p">{</span>
<a name="True-9"></a>    <span class="n">AudioServicesAddSystemSoundCompletion</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">VibratePlayComplete</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">);</span>
<a name="True-10"></a>    <span class="n">AudioServicesPlaySystemSound</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">);</span>
<a name="True-11"></a><span class="p">}</span></code></pre></div>
<p>这里振动实现与播放提示音方法基本一致，只是传的soundID参数不同，在播放提示音时ssid是根据我们的音频文件生成的，而振动是系统定义的。振动完成后也有回调方法进行特殊处理，与播放声音的实现一致。</p>

<p>通过上面的方法我们就实现了消息提示音及振动，这里只是简单的实现，但是在实际场景下还需要添加其他的逻辑处理，比如连续收消息，不能一直播放提示音或是振动吧，用户会不爽的，可以在播放完成提示音后设置一个时间间隔，比如2秒钟内收到消息就不播提示音不振动，超过2秒再有提示，这些都需要根据具体业务需求来处理了。</p>

<p>既然已经实现了播放提示音与振动，那如果我想根据系统是否静音来选择哪种提示：</p>

<ul>
  <li>如果系统是静音模式，消息提示为振动</li>
  <li>如果系统是正常模式，消息提示为提示音</li>
</ul>

<p>看起来不难嘛，我们读取系统的音量，根据音量大小来判断系统是否是静音不就OK了，那如何读取系统音量呢，一番查资料后，找到如下几种方案：</p>

<h4 id="section-2">方案1：</h4>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a><span class="n">Float32</span> <span class="n">volume</span><span class="p">;</span>
<a name="True-2"></a><span class="kt">UInt32</span> <span class="n">dataSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Float32</span><span class="p">);</span>
<a name="True-3"></a><span class="n">AudioSessionGetProperty</span> <span class="p">(</span>
<a name="True-4"></a>                     <span class="n">kAudioSessionProperty_CurrentHardwareOutputVolume</span><span class="p">,</span>
<a name="True-5"></a>                     <span class="o">&amp;</span><span class="n">dataSize</span><span class="p">,</span>
<a name="True-6"></a>                     <span class="o">&amp;</span><span class="n">volume</span>
<a name="True-7"></a>                     <span class="p">);</span></code></pre></div>
<p>该方案中获取的音量值一直不变。放弃！</p>

<h4 id="httpblogcsdnnetslinlossarticledetails7870559">方案2：<a href="http://blog.csdn.net/slinloss/article/details/7870559">链接</a></h4>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a> <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">isMuted</span>  
<a name="True-2"></a><span class="p">{</span>  
<a name="True-3"></a>    <span class="n">CFStringRef</span> <span class="n">route</span><span class="p">;</span>  
<a name="True-4"></a>    <span class="kt">UInt32</span> <span class="n">routeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CFStringRef</span><span class="p">);</span>  
<a name="True-5"></a>    <span class="n">OSStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AudioSessionGetProperty</span><span class="p">(</span><span class="n">kAudioSessionProperty_AudioRoute</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">routeSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">route</span><span class="p">);</span>  
<a name="True-6"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">kAudioSessionNoError</span><span class="p">)</span>  
<a name="True-7"></a>    <span class="p">{</span>  
<a name="True-8"></a>        <span class="k">if</span> <span class="p">(</span><span class="n">route</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">CFStringGetLength</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>  
<a name="True-9"></a>            <span class="k">return</span> <span class="nb">TRUE</span><span class="p">;</span>  
<a name="True-10"></a>    <span class="p">}</span>  
<a name="True-11"></a>    <span class="k">return</span> <span class="nb">FALSE</span><span class="p">;</span>  
<a name="True-12"></a><span class="p">}</span> 
<a name="True-13"></a>
<a name="True-14"></a> <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">addMutedListener</span>  
<a name="True-15"></a><span class="p">{</span>  
<a name="True-16"></a>    <span class="n">OSStatus</span> <span class="n">s</span> <span class="o">=</span> <span class="n">AudioSessionAddPropertyListener</span><span class="p">(</span><span class="n">kAudioSessionProperty_AudioRouteChange</span><span class="p">,</span>  
<a name="True-17"></a>    <span class="n">audioRouteChangeListenerCallback</span><span class="p">,</span>  
<a name="True-18"></a>    <span class="nb">self</span><span class="p">);</span>  
<a name="True-19"></a>    <span class="k">return</span> <span class="n">s</span> <span class="o">==</span> <span class="n">kAudioSessionNoError</span><span class="p">;</span>  
<a name="True-20"></a><span class="p">}</span>  
<a name="True-21"></a><span class="kt">void</span> <span class="n">audioRouteChangeListenerCallback</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">inUserData</span><span class="p">,</span>  
<a name="True-22"></a>                                       <span class="n">AudioSessionPropertyID</span> <span class="n">inPropertyID</span><span class="p">,</span>  
<a name="True-23"></a>                                       <span class="kt">UInt32</span> <span class="n">inPropertyValueSize</span><span class="p">,</span>  
<a name="True-24"></a>                                       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">inPropertyValue</span>  
<a name="True-25"></a>                                       <span class="p">)</span>  
<a name="True-26"></a><span class="p">{</span>  
<a name="True-27"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">inPropertyID</span> <span class="o">!=</span> <span class="n">kAudioSessionProperty_AudioRouteChange</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>  
<a name="True-28"></a>    <span class="kt">BOOL</span> <span class="n">muted</span> <span class="o">=</span> <span class="p">[</span><span class="n">mediaVolume</span> <span class="n">isMuted</span><span class="p">];</span>  
<a name="True-29"></a>    <span class="c1">// add code here  </span>
<a name="True-30"></a><span class="p">}</span></code></pre></div>
<p>该方案中使用的方法在iOS7中已不建议使用了，而且该方案在尝试的过程中一直不成功。</p>

<h4 id="httpsharkfoodcomcontentdeveloperscontentsound20switch">方案3：<a href="http://sharkfood.com/content/Developers/content/Sound%20Switch/">链接</a></h4>

<p>该方案中使用的方法是播放一段无声的系统声，判断播放完成所需要的时间，如果获得的时长接近0则表示系统处于静音状态。该方案通过笨方法实现静音的检测，虽然性能不高，因为要一直循环着播放无声的音频文件来检测系统静音状态，但是可以通过正常的API调用来得到系统状态。</p>

<p>根据上面的三种方案感觉通过判断系统音量的方案可以放弃了，再想想其他办法，随着iOS系统的不断完善，硬件也有直接切换静音的按钮(可设置)，系统会不会自动帮我们处理静音振动与非静音播放声音呢？</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playMsgSound</span>
<a name="True-2"></a><span class="p">{</span>
<a name="True-3"></a>    <span class="p">[</span><span class="nb">self</span> <span class="n">playDefaultSound</span><span class="p">];</span>
<a name="True-4"></a>    <span class="p">[</span><span class="nb">self</span> <span class="n">playVibrate</span><span class="p">];</span>
<a name="True-5"></a><span class="p">}</span></code></pre></div>
<p>摒着试一试的心态在收到消息时先播放声音，再振动，并尝试通过按键设置系统的静音状态，这里先说明一下iOS系统的设置里针对振动的设置项：</p>

<ol>
  <li>响铃模式振动</li>
  <li>静音模式振动</li>
</ol>

<ul>
  <li>关闭1，在收到消息时切换静音状态，可以得到结果静音下只振动，非静音下只播放声音</li>
  <li>关闭2，静音下不振动也没有播放声音，非静音下，振动+播放声音</li>
  <li>关闭1和2，不管在静音状态还是非静音状态都没振动和声音</li>
  <li>打开1和2，静音下振动，非静音下振动+声音</li>
</ul>

<p>因此我们可以得出系统已经根据用户的设置自动选择了振动与声音模式，我们可以不用判断系统音量来选择振动或是播放声音了，直接播放声音，然后振动。到此问题算是解决了。</p>

<h3 id="section-3">插播一黑魔法</h3>

<p>在上面的方法中振动我们使用系统定义的<code>kSystemSoundID_Vibrate</code>来实现，如果在设置中关闭振动选项，就不会再振动了，如果此时不管怎样都要振动，该怎么办呢？黑魔法黑科技来拯救你：</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><a name="True-1"></a><span class="cp">#define kSystemSoundID_Vibrate 1352</span>
<a name="True-2"></a><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playVibrate</span>
<a name="True-3"></a><span class="p">{</span>
<a name="True-4"></a>    <span class="n">AudioServicesAddSystemSoundCompletion</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">VibratePlayComplete</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">);</span>
<a name="True-5"></a>    <span class="n">AudioServicesPlaySystemSound</span><span class="p">(</span><span class="n">kSystemSoundID_Vibrate</span><span class="p">);</span>
<a name="True-6"></a><span class="p">}</span></code></pre></div>
<p>1352 完全无视系统的静音振动设置，至于为什么会成功还没有深入研究。待补充~~</p>

<p>如果使用该方法能不能正常通过苹果审核不确定，如若被拒，后果自负~~</p>

<h4 id="section-4">参考</h4>
<ul>
  <li><a href="http://stackoverflow.com/questions/4724980/making-the-iphone-vibrate?rq=1">http://stackoverflow.com/questions/4724980/making-the-iphone-vibrate?rq=1</a></li>
  <li><a href="https://github.com/TUNER88/iOSSystemSoundsLibrary">https://github.com/TUNER88/iOSSystemSoundsLibrary</a></li>
  <li><a href="http://sharkfood.com/content/Developers/content/Sound%20Switch/">http://sharkfood.com/content/Developers/content/Sound%20Switch/</a></li>
  <li><a href="http://blog.csdn.net/slinloss/article/details/7870559">http://blog.csdn.net/slinloss/article/details/7870559</a></li>
</ul>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
